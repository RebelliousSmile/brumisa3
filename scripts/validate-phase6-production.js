#!/usr/bin/env node

/**
 * Script de validation Phase 6 : Performance et Production
 * V√©rifie que toutes les optimisations et configurations sont en place
 */

const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const util = require('util');

const execAsync = util.promisify(exec);

// Configuration des v√©rifications
const REQUIRED_FILES = [
    // Services de performance
    'src/services/CacheService.js',
    'src/services/QueueService.js', 
    'src/services/PerformanceMonitoringService.js',
    'src/services/SecurityService.js',
    'src/services/LoggingService.js',
    
    // Middleware
    'src/middleware/performance.js',
    
    // Workers
    'src/workers/queue-worker.js',
    'src/workers/maintenance-worker.js',
    
    // Configuration production
    '.env.production',
    'ecosystem.config.js',
    'nginx.conf',
    
    // Scripts de d√©ploiement
    'scripts/deploy/deploy.sh',
    'scripts/deploy/setup-permissions.sh',
    'scripts/backup/auto-backup.sh',
    'scripts/monitoring/health-check.js',
    
    // Application optimis√©e
    'src/app-production.js'
];

const PERFORMANCE_TARGETS = {
    pdf_generation: 2000, // 2 secondes selon TODO.md
    api_response: 500     // 500ms selon TODO.md
};

/**
 * Classe de validation Phase 6
 */
class Phase6Validator {
    constructor() {
        this.results = [];
        this.errors = [];
        this.warnings = [];
        this.startTime = Date.now();
    }

    /**
     * Log un r√©sultat de validation
     */
    logResult(check, status, message, details = {}) {
        const result = {
            check,
            status, // 'pass', 'fail', 'warning'
            message,
            details,
            timestamp: Date.now()
        };
        
        this.results.push(result);
        
        const icon = status === 'pass' ? '‚úÖ' : status === 'fail' ? '‚ùå' : '‚ö†Ô∏è';
        console.log(`${icon} ${check}: ${message}`);
        
        if (status === 'fail') {
            this.errors.push(result);
        } else if (status === 'warning') {
            this.warnings.push(result);
        }
    }

    /**
     * V√©rifie la pr√©sence des fichiers requis
     */
    async checkRequiredFiles() {
        console.log('\nüìÅ V√©rification des fichiers requis...');
        
        let missingFiles = [];
        
        for (const file of REQUIRED_FILES) {
            const fullPath = path.resolve(file);
            
            try {
                const stats = fs.statSync(fullPath);
                
                if (stats.isFile()) {
                    this.logResult(
                        `file_${path.basename(file)}`,
                        'pass',
                        `Fichier pr√©sent: ${file}`,
                        { size: stats.size, path: fullPath }
                    );
                } else {
                    this.logResult(
                        `file_${path.basename(file)}`,
                        'fail',
                        `N'est pas un fichier: ${file}`
                    );
                    missingFiles.push(file);
                }
            } catch (error) {
                this.logResult(
                    `file_${path.basename(file)}`,
                    'fail',
                    `Fichier manquant: ${file}`,
                    { error: error.message }
                );
                missingFiles.push(file);
            }
        }
        
        if (missingFiles.length === 0) {
            this.logResult('required_files', 'pass', 
                `Tous les fichiers requis sont pr√©sents (${REQUIRED_FILES.length})`);
        } else {
            this.logResult('required_files', 'fail', 
                `${missingFiles.length} fichiers manquants`, 
                { missingFiles });
        }
    }

    /**
     * V√©rifie la configuration des variables d'environnement
     */
    async checkEnvironmentConfig() {
        console.log('\nüîß V√©rification de la configuration environnement...');
        
        const productionEnvPath = path.resolve('.env.production');
        
        try {
            const envContent = fs.readFileSync(productionEnvPath, 'utf8');
            const envVars = envContent.split('\n')
                .filter(line => line.includes('=') && !line.startsWith('#'))
                .map(line => line.split('=')[0]);
            
            // Variables critiques pour la production
            const criticalVars = [
                'NODE_ENV',
                'DATABASE_URL',
                'SESSION_SECRET',
                'HTTPS_ENABLED',
                'SSL_CERT_PATH',
                'SSL_KEY_PATH',
                'LOG_LEVEL',
                'CACHE_DEFAULT_TTL',
                'QUEUE_MAX_CONCURRENCY',
                'PDF_GENERATION_TARGET',
                'API_RESPONSE_TARGET'
            ];
            
            const missingCritical = criticalVars.filter(v => !envVars.includes(v));
            
            if (missingCritical.length === 0) {
                this.logResult('env_config', 'pass', 
                    'Configuration environnement compl√®te',
                    { totalVars: envVars.length, criticalVars: criticalVars.length });
            } else {
                this.logResult('env_config', 'fail', 
                    'Variables d\'environnement critiques manquantes',
                    { missing: missingCritical });
            }
            
            // V√©rifier les valeurs par d√©faut dangereuses
            const dangerousDefaults = [
                'SESSION_SECRET=your-super-secret',
                'CODE_PREMIUM=123456',
                'CODE_ADMIN=789012'
            ];
            
            const foundDangerous = dangerousDefaults.filter(d => 
                envContent.includes(d.split('=')[1]));
                
            if (foundDangerous.length > 0) {
                this.logResult('env_security', 'fail', 
                    'Valeurs par d√©faut dangereuses d√©tect√©es',
                    { dangerous: foundDangerous });
            } else {
                this.logResult('env_security', 'pass', 
                    'Pas de valeurs par d√©faut dangereuses');
            }
            
        } catch (error) {
            this.logResult('env_config', 'fail', 
                'Impossible de lire .env.production',
                { error: error.message });
        }
    }

    /**
     * V√©rifie la configuration PM2
     */
    async checkPM2Config() {
        console.log('\nüîÑ V√©rification de la configuration PM2...');
        
        try {
            const ecosystemPath = path.resolve('ecosystem.config.js');
            const ecosystemContent = fs.readFileSync(ecosystemPath, 'utf8');
            
            const requiredPM2Features = [
                'cluster',
                'max_memory_restart',
                'env_production',
                'log_file',
                'graceful_shutdown'
            ];
            
            const presentFeatures = requiredPM2Features.filter(feature => 
                ecosystemContent.includes(feature));
            
            if (presentFeatures.length === requiredPM2Features.length) {
                this.logResult('pm2_config', 'pass', 
                    'Configuration PM2 compl√®te',
                    { features: presentFeatures });
            } else {
                const missing = requiredPM2Features.filter(f => 
                    !presentFeatures.includes(f));
                this.logResult('pm2_config', 'warning', 
                    'Configuration PM2 incompl√®te',
                    { missing, present: presentFeatures });
            }
            
            // V√©rifier les workers
            if (ecosystemContent.includes('queue-worker') && 
                ecosystemContent.includes('maintenance-worker')) {
                this.logResult('pm2_workers', 'pass', 
                    'Workers PM2 configur√©s');
            } else {
                this.logResult('pm2_workers', 'warning', 
                    'Workers PM2 manquants ou mal configur√©s');
            }
            
        } catch (error) {
            this.logResult('pm2_config', 'fail', 
                'Erreur lors de la v√©rification PM2',
                { error: error.message });
        }
    }

    /**
     * V√©rifie la configuration Nginx
     */
    async checkNginxConfig() {
        console.log('\nüåê V√©rification de la configuration Nginx...');
        
        try {
            const nginxPath = path.resolve('nginx.conf');
            const nginxContent = fs.readFileSync(nginxPath, 'utf8');
            
            const requiredNginxFeatures = [
                'ssl_protocols',
                'gzip on',
                'limit_req_zone',
                'proxy_pass',
                'add_header X-Frame-Options',
                'upstream brumisater_app',
                'location /health',
                'location /metrics'
            ];
            
            const presentFeatures = requiredNginxFeatures.filter(feature => 
                nginxContent.includes(feature));
            
            if (presentFeatures.length >= requiredNginxFeatures.length * 0.8) {
                this.logResult('nginx_config', 'pass', 
                    'Configuration Nginx appropri√©e',
                    { features: presentFeatures.length, total: requiredNginxFeatures.length });
            } else {
                this.logResult('nginx_config', 'warning', 
                    'Configuration Nginx incompl√®te',
                    { present: presentFeatures.length, total: requiredNginxFeatures.length });
            }
            
        } catch (error) {
            this.logResult('nginx_config', 'warning', 
                'Fichier nginx.conf non trouv√© (normal si non utilis√©)',
                { error: error.message });
        }
    }

    /**
     * V√©rifie les services de performance
     */
    async checkPerformanceServices() {
        console.log('\n‚ö° V√©rification des services de performance...');
        
        const serviceChecks = [
            {
                name: 'CacheService',
                file: 'src/services/CacheService.js',
                methods: ['set', 'get', 'getOrSet', 'cleanup', 'getStats']
            },
            {
                name: 'QueueService', 
                file: 'src/services/QueueService.js',
                methods: ['add', 'processQueue', 'getGlobalStats']
            },
            {
                name: 'PerformanceMonitoringService',
                file: 'src/services/PerformanceMonitoringService.js',
                methods: ['middleware', 'recordRequest', 'generatePerformanceReport']
            }
        ];
        
        for (const service of serviceChecks) {
            try {
                const servicePath = path.resolve(service.file);
                const serviceContent = fs.readFileSync(servicePath, 'utf8');
                
                const presentMethods = service.methods.filter(method => 
                    serviceContent.includes(method));
                
                if (presentMethods.length >= service.methods.length * 0.8) {
                    this.logResult(`service_${service.name}`, 'pass', 
                        `${service.name} complet`,
                        { methods: presentMethods.length, total: service.methods.length });
                } else {
                    this.logResult(`service_${service.name}`, 'warning', 
                        `${service.name} incomplet`,
                        { present: presentMethods, missing: service.methods.filter(m => !presentMethods.includes(m)) });
                }
                
            } catch (error) {
                this.logResult(`service_${service.name}`, 'fail', 
                    `Erreur lors de la v√©rification de ${service.name}`,
                    { error: error.message });
            }
        }
    }

    /**
     * V√©rifie les cibles de performance
     */
    async checkPerformanceTargets() {
        console.log('\nüéØ V√©rification des cibles de performance...');
        
        // V√©rifier que les cibles sont d√©finies dans le code
        try {
            const appProductionPath = path.resolve('src/app-production.js');
            const appContent = fs.readFileSync(appProductionPath, 'utf8');
            
            const hasApiTarget = appContent.includes('500ms') || appContent.includes('API_RESPONSE_TARGET');
            const hasPdfTarget = appContent.includes('2000ms') || appContent.includes('PDF_GENERATION_TARGET');
            
            if (hasApiTarget && hasPdfTarget) {
                this.logResult('performance_targets', 'pass', 
                    'Cibles de performance configur√©es (API: 500ms, PDF: 2s)');
            } else {
                this.logResult('performance_targets', 'warning', 
                    'Cibles de performance non configur√©es',
                    { hasApiTarget, hasPdfTarget });
            }
            
        } catch (error) {
            this.logResult('performance_targets', 'warning', 
                'Impossible de v√©rifier les cibles de performance',
                { error: error.message });
        }
        
        // V√©rifier la pr√©sence du monitoring
        try {
            const perfMiddlewarePath = path.resolve('src/middleware/performance.js');
            const perfContent = fs.readFileSync(perfMiddlewarePath, 'utf8');
            
            if (perfContent.includes('monitorAPI') && perfContent.includes('monitorPDF')) {
                this.logResult('performance_monitoring', 'pass', 
                    'Monitoring de performance configur√©');
            } else {
                this.logResult('performance_monitoring', 'warning', 
                    'Monitoring de performance incomplet');
            }
            
        } catch (error) {
            this.logResult('performance_monitoring', 'fail', 
                'Middleware de monitoring manquant',
                { error: error.message });
        }
    }

    /**
     * V√©rifie les scripts de d√©ploiement
     */
    async checkDeploymentScripts() {
        console.log('\nüöÄ V√©rification des scripts de d√©ploiement...');
        
        const deploymentScripts = [
            'scripts/deploy/deploy.sh',
            'scripts/deploy/setup-permissions.sh',
            'scripts/backup/auto-backup.sh',
            'scripts/monitoring/health-check.js'
        ];
        
        for (const script of deploymentScripts) {
            try {
                const scriptPath = path.resolve(script);
                const stats = fs.statSync(scriptPath);
                
                // V√©rifier que les scripts sont ex√©cutables
                const isExecutable = (stats.mode & parseInt('111', 8)) !== 0;
                
                if (isExecutable || script.endsWith('.js')) {
                    this.logResult(`script_${path.basename(script, path.extname(script))}`, 
                        'pass', 
                        `Script d√©ploiement OK: ${path.basename(script)}`,
                        { size: stats.size, executable: isExecutable });
                } else {
                    this.logResult(`script_${path.basename(script, path.extname(script))}`, 
                        'warning', 
                        `Script non ex√©cutable: ${path.basename(script)}`);
                }
                
            } catch (error) {
                this.logResult(`script_${path.basename(script, path.extname(script))}`, 
                    'fail', 
                    `Script manquant: ${path.basename(script)}`,
                    { error: error.message });
            }
        }
    }

    /**
     * V√©rifie les d√©pendances de production
     */
    async checkDependencies() {
        console.log('\nüì¶ V√©rification des d√©pendances...');
        
        try {
            const packagePath = path.resolve('package.json');
            const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
            
            const productionDeps = [
                'winston',        // Logging avanc√©
                'helmet',         // S√©curit√©
                'express-rate-limit', // Rate limiting
                // Les autres sont d√©j√† pr√©sentes
            ];
            
            const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };
            const missingDeps = productionDeps.filter(dep => !dependencies[dep]);
            
            if (missingDeps.length === 0) {
                this.logResult('dependencies', 'pass', 
                    'Toutes les d√©pendances de production pr√©sentes');
            } else {
                this.logResult('dependencies', 'warning', 
                    'D√©pendances manquantes pour production optimale',
                    { missing: missingDeps });
            }
            
            // V√©rifier les scripts package.json
            const requiredScripts = [
                'start',
                'build:css', 
                'test',
                'lint'
            ];
            
            const presentScripts = requiredScripts.filter(script => 
                packageJson.scripts && packageJson.scripts[script]);
            
            if (presentScripts.length >= requiredScripts.length * 0.8) {
                this.logResult('package_scripts', 'pass', 
                    'Scripts package.json appropri√©s');
            } else {
                this.logResult('package_scripts', 'warning', 
                    'Scripts package.json incomplets',
                    { present: presentScripts, required: requiredScripts });
            }
            
        } catch (error) {
            this.logResult('dependencies', 'fail', 
                'Erreur lors de la v√©rification des d√©pendances',
                { error: error.message });
        }
    }

    /**
     * G√©n√®re le rapport final
     */
    generateReport() {
        const duration = Date.now() - this.startTime;
        
        const summary = {
            total: this.results.length,
            passed: this.results.filter(r => r.status === 'pass').length,
            failed: this.errors.length,
            warnings: this.warnings.length
        };
        
        const successRate = Math.round((summary.passed / summary.total) * 100);
        
        console.log('\n' + '='.repeat(60));
        console.log('üìä RAPPORT DE VALIDATION PHASE 6 - PERFORMANCE ET PRODUCTION');
        console.log('='.repeat(60));
        
        console.log(`\nüéØ R√©sum√©:`);
        console.log(`   Total des v√©rifications: ${summary.total}`);
        console.log(`   ‚úÖ R√©ussies: ${summary.passed} (${successRate}%)`);
        console.log(`   ‚ùå √âchou√©es: ${summary.failed}`);
        console.log(`   ‚ö†Ô∏è Avertissements: ${summary.warnings}`);
        console.log(`   ‚è±Ô∏è Dur√©e: ${duration}ms`);
        
        if (this.errors.length > 0) {
            console.log('\n‚ùå Erreurs critiques:');
            this.errors.forEach(error => {
                console.log(`   - ${error.check}: ${error.message}`);
            });
        }
        
        if (this.warnings.length > 0) {
            console.log('\n‚ö†Ô∏è Avertissements:');
            this.warnings.forEach(warning => {
                console.log(`   - ${warning.check}: ${warning.message}`);
            });
        }
        
        // Statut global
        let globalStatus = 'SUCCESS';
        let exitCode = 0;
        
        if (this.errors.length > 0) {
            globalStatus = 'FAILED';
            exitCode = 1;
        } else if (this.warnings.length > 0) {
            globalStatus = 'WARNING';
        }
        
        console.log(`\nüèÅ Statut global: ${globalStatus}`);
        
        if (globalStatus === 'SUCCESS') {
            console.log('\nüéâ Phase 6 : Performance et Production - VALID√âE !');
            console.log('‚úÖ L\'application est pr√™te pour un d√©ploiement production optimis√©');
            console.log('üìà Cibles: API < 500ms, PDF < 2s');
            console.log('üîí S√©curit√© et monitoring configur√©s');
        } else if (globalStatus === 'WARNING') {
            console.log('\n‚ö†Ô∏è Phase 6 : Performance et Production - PARTIELLEMENT VALID√âE');
            console.log('üìù Corrigez les avertissements pour un d√©ploiement optimal');
        } else {
            console.log('\n‚ùå Phase 6 : Performance et Production - √âCHEC');
            console.log('üîß Corrigez les erreurs critiques avant le d√©ploiement');
        }
        
        return exitCode;
    }

    /**
     * Ex√©cute toutes les validations
     */
    async runAllValidations() {
        console.log('üîç Validation Phase 6 : Performance et Production');
        console.log('üìÖ ' + new Date().toISOString());
        
        await this.checkRequiredFiles();
        await this.checkEnvironmentConfig();
        await this.checkPM2Config();
        await this.checkNginxConfig();
        await this.checkPerformanceServices();
        await this.checkPerformanceTargets();
        await this.checkDeploymentScripts();
        await this.checkDependencies();
        
        return this.generateReport();
    }
}

// Fonction principale
async function main() {
    const validator = new Phase6Validator();
    
    try {
        const exitCode = await validator.runAllValidations();
        process.exit(exitCode);
        
    } catch (error) {
        console.error('‚ùå Erreur fatale lors de la validation:', error);
        process.exit(2);
    }
}

// Ex√©cuter si appel√© directement
if (require.main === module) {
    main().catch(error => {
        console.error('Erreur fatale:', error);
        process.exit(2);
    });
}

module.exports = Phase6Validator;