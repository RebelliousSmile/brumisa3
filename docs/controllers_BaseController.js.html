<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: controllers/BaseController.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: controllers/BaseController.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const logManager = require('../utils/logManager');

/**
 * Contrôleur de base avec gestion d'erreurs unifiée
 * Principe SOLID : Interface Segregation + DRY
 */
class BaseController {
    constructor(nomControleur) {
        this.logger = logManager;
        this.nomControleur = nomControleur;
    }

    /**
     * Gère les erreurs de manière uniforme (DRY)
     */
    gererErreur(res, erreur, codeStatut = 500) {
        this.logger.error(`Erreur dans ${this.nomControleur}:`, {
            message: erreur.message,
            stack: erreur.stack,
            code: erreur.code
        });
        
        // Gestion spécifique selon le type d'erreur
        if (erreur.name === 'ValidationError') {
            return this.repondreErreur(res, 400, erreur.message, 'validation', erreur.details);
        }
        
        if (erreur.code === 'ENOTFOUND' || erreur.code === 'ECONNREFUSED') {
            return this.repondreErreur(res, 503, 'Service temporairement indisponible', 'service');
        }
        
        if (erreur.message.includes('duplicate') || erreur.code === '23505') {
            return this.repondreErreur(res, 409, 'Cette ressource existe déjà', 'conflit');
        }
        
        if (erreur.message.includes('not found') || erreur.code === 'ENOENT') {
            return this.repondreErreur(res, 404, 'Ressource non trouvée', 'non_trouve');
        }
        
        // Erreur générique
        const messagePublic = process.env.NODE_ENV === 'production' 
            ? 'Erreur interne du serveur'
            : erreur.message;
            
        return this.repondreErreur(res, codeStatut, messagePublic, 'erreur_interne');
    }

    /**
     * Formate une réponse d'erreur standardisée
     */
    repondreErreur(res, statut, message, type = 'erreur', details = null) {
        const reponse = {
            succes: false,
            message,
            type,
            timestamp: new Date().toISOString()
        };
        
        if (details &amp;&amp; process.env.NODE_ENV !== 'production') {
            reponse.details = details;
        }
        
        return res.status(statut).json(reponse);
    }

    /**
     * Formate une réponse de succès standardisée
     */
    repondreSucces(res, donnees = null, message = 'Opération réussie', statut = 200) {
        const reponse = {
            succes: true,
            message,
            timestamp: new Date().toISOString()
        };
        
        if (donnees !== null) {
            reponse.donnees = donnees;
        }
        
        return res.status(statut).json(reponse);
    }

    /**
     * Valide les paramètres requis
     */
    validerParametres(req, parametresRequis) {
        const erreurs = [];
        
        parametresRequis.forEach(param => {
            const valeur = req.body[param] || req.params[param] || req.query[param];
            if (valeur === undefined || valeur === null || valeur === '') {
                erreurs.push(`Le paramètre '${param}' est requis`);
            }
        });
        
        if (erreurs.length > 0) {
            const erreur = new Error(erreurs.join(', '));
            erreur.name = 'ValidationError';
            erreur.details = erreurs;
            throw erreur;
        }
    }

    /**
     * Valide les champs requis dans le corps de la requête
     */
    validerCorps(req, champsRequis) {
        const erreurs = [];
        
        champsRequis.forEach(champ => {
            const valeur = req.body[champ];
            if (valeur === undefined || valeur === null || valeur === '') {
                erreurs.push(`Le champ '${champ}' est requis`);
            }
        });
        
        if (erreurs.length > 0) {
            const erreur = new Error(erreurs.join(', '));
            erreur.name = 'ValidationError';
            erreur.details = erreurs;
            throw erreur;
        }
    }

    /**
     * Valide les permissions utilisateur
     */
    verifierPermissions(req, roleRequis = 'UTILISATEUR') {
        if (!req.session || !req.session.utilisateur) {
            const erreur = new Error('Authentification requise');
            erreur.code = 'UNAUTHORIZED';
            throw erreur;
        }
        
        const utilisateur = req.session.utilisateur;
        const rolesHierarchie = ['UTILISATEUR', 'PREMIUM', 'ADMIN'];
        const roleUtilisateur = rolesHierarchie.indexOf(utilisateur.role);
        const roleMin = rolesHierarchie.indexOf(roleRequis);
        
        if (roleUtilisateur &lt; roleMin) {
            const erreur = new Error(`Rôle ${roleRequis} requis (actuel: ${utilisateur.role})`);
            erreur.code = 'FORBIDDEN';
            throw erreur;
        }
        
        return utilisateur;
    }

    /**
     * Valide qu'un utilisateur peut accéder à une ressource
     */
    verifierProprietaire(req, ressourceUserId) {
        const utilisateur = this.verifierPermissions(req);
        
        // Admin peut tout voir
        if (utilisateur.role === 'ADMIN') {
            return utilisateur;
        }
        
        // Vérifier que l'utilisateur est le propriétaire
        if (utilisateur.id !== ressourceUserId) {
            const erreur = new Error('Accès non autorisé à cette ressource');
            erreur.code = 'FORBIDDEN';
            throw erreur;
        }
        
        return utilisateur;
    }

    /**
     * Extrait les paramètres de pagination
     */
    extrairePagination(req) {
        const page = parseInt(req.query.page) || 1;
        const limite = Math.min(parseInt(req.query.limite) || 20, 100); // Max 100
        const offset = (page - 1) * limite;
        
        return { page, limite, offset };
    }

    /**
     * Formate une réponse paginée
     */
    repondrePagine(res, donnees, pagination, message = 'Données récupérées') {
        return this.repondreSucces(res, {
            items: donnees,
            pagination: {
                page: pagination.page,
                limite: pagination.limite,
                total: pagination.total,
                pages: Math.ceil(pagination.total / pagination.limite),
                hasNext: pagination.page &lt; Math.ceil(pagination.total / pagination.limite),
                hasPrev: pagination.page > 1
            }
        }, message);
    }

    /**
     * Middleware pour wrapper les méthodes async et gérer les erreurs
     */
    wrapAsync(fn) {
        return (req, res, next) => {
            Promise.resolve(fn.call(this, req, res, next)).catch(erreur => {
                this.gererErreur(res, erreur);
            });
        };
    }

    /**
     * Middleware pour logger les requêtes
     */
    loggerRequete(req, res, next) {
        const debut = Date.now();
        
        // Log de la requête entrante
        this.logger.info(`${req.method} ${req.path}`, {
            ip: req.ip,
            userAgent: req.get('user-agent'),
            utilisateur: req.session?.utilisateur?.id || 'anonyme'
        });
        
        // Log de la réponse
        res.on('finish', () => {
            const duree = Date.now() - debut;
            this.logger.info(`Response ${res.statusCode}`, {
                method: req.method,
                path: req.path,
                status: res.statusCode,
                duree: `${duree}ms`
            });
        });
        
        next();
    }

    /**
     * Sanitize les données entrantes
     */
    sanitizeInput(data) {
        if (typeof data === 'string') {
            return data.trim();
        }
        
        if (Array.isArray(data)) {
            return data.map(item => this.sanitizeInput(item));
        }
        
        if (typeof data === 'object' &amp;&amp; data !== null) {
            const sanitized = {};
            Object.keys(data).forEach(key => {
                sanitized[key] = this.sanitizeInput(data[key]);
            });
            return sanitized;
        }
        
        return data;
    }

    /**
     * Valide le format email
     */
    validerEmail(email) {
        const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return regex.test(email);
    }

    /**
     * Génère un ID unique
     */
    genererIdUnique() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
}

module.exports = BaseController;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Actualite.html">Actualite</a></li><li><a href="AdminController.html">AdminController</a></li><li><a href="AnonymousTokenService.html">AnonymousTokenService</a></li><li><a href="AuthentificationController.html">AuthentificationController</a></li><li><a href="BaseController.html">BaseController</a></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="BasePdfKitService.html">BasePdfKitService</a></li><li><a href="BaseService.html">BaseService</a></li><li><a href="CharacterSheetDocument.html">CharacterSheetDocument</a></li><li><a href="ClassPlanDocument.html">ClassPlanDocument</a></li><li><a href="DocumentFactory.html">DocumentFactory</a></li><li><a href="DonationController.html">DonationController</a></li><li><a href="GenericDocument.html">GenericDocument</a></li><li><a href="HomeController.html">HomeController</a></li><li><a href="MarkdownService.html">MarkdownService</a></li><li><a href="MonsterheartsTheme.html">MonsterheartsTheme</a></li><li><a href="Newsletter.html">Newsletter</a></li><li><a href="NewsletterService.html">NewsletterService</a></li><li><a href="Oracle.html">Oracle</a></li><li><a href="OracleController.html">OracleController</a></li><li><a href="OracleItem.html">OracleItem</a></li><li><a href="OracleService.html">OracleService</a></li><li><a href="Pdf.html">Pdf</a></li><li><a href="PdfController.html">PdfController</a></li><li><a href="PdfKitService.html">PdfKitService</a></li><li><a href="PdfService.html">PdfService</a></li><li><a href="Personnage.html">Personnage</a></li><li><a href="PersonnageController.html">PersonnageController</a></li><li><a href="PersonnageService.html">PersonnageService</a></li><li><a href="SystemRightsService.html">SystemRightsService</a></li><li><a href="SystemTheme.html">SystemTheme</a></li><li><a href="Temoignage.html">Temoignage</a></li><li><a href="TemoignageService.html">TemoignageService</a></li><li><a href="TemplateService.html">TemplateService</a></li><li><a href="Utilisateur.html">Utilisateur</a></li><li><a href="UtilisateurService.html">UtilisateurService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#compareVersions">compareVersions</a></li><li><a href="global.html#createMigrationsTable">createMigrationsTable</a></li><li><a href="global.html#createTables">createTables</a></li><li><a href="global.html#executeMigration">executeMigration</a></li><li><a href="global.html#getCurrentVersion">getCurrentVersion</a></li><li><a href="global.html#getExecutedMigrations">getExecutedMigrations</a></li><li><a href="global.html#getMigrationStatus">getMigrationStatus</a></li><li><a href="global.html#getVersionsToMigrate">getVersionsToMigrate</a></li><li><a href="global.html#initializeDatabase">initializeDatabase</a></li><li><a href="global.html#isDatabaseInitialized">isDatabaseInitialized</a></li><li><a href="global.html#markMigrationExecuted">markMigrationExecuted</a></li><li><a href="global.html#migrateDatabase">migrateDatabase</a></li><li><a href="global.html#migrateToLatest">migrateToLatest</a></li><li><a href="global.html#migrateToVersion">migrateToVersion</a></li><li><a href="global.html#migrations">migrations</a></li><li><a href="global.html#resetDatabase">resetDatabase</a></li><li><a href="global.html#rollbackMigration">rollbackMigration</a></li><li><a href="global.html#updateAppVersion">updateAppVersion</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Jul 22 2025 09:21:38 GMT+0200 (heure d’été d’Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
