<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: database/db.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: database/db.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { Pool } = require('pg');
const config = require('../config');
const logManager = require('../utils/logManager');

class DatabaseManager {
  constructor() {
    this.pool = null;
    this.isConnected = false;
  }

  /**
   * Initialise la connexion PostgreSQL
   */
  async init() {
    try {
      // Configuration de la pool de connexions PostgreSQL
      this.pool = new Pool({
        host: config.database.host,
        port: config.database.port,
        database: config.database.database,
        user: config.database.user,
        password: config.database.password,
        ssl: config.database.ssl || false,
        max: 20, // Maximum 20 connexions dans la pool
        idleTimeoutMillis: 30000,
        connectionTimeoutMillis: 2000,
      });

      // Test de connexion
      const client = await this.pool.connect();
      await client.query('SELECT NOW()');
      client.release();

      this.isConnected = true;
      logManager.info('Base de données PostgreSQL initialisée', {
        host: config.database.host,
        port: config.database.port,
        database: config.database.database
      });
      
      return true;
      
    } catch (error) {
      logManager.error('Erreur initialisation base de données PostgreSQL', { 
        error: error.message,
        host: config.database.host,
        port: config.database.port,
        database: config.database.database
      });
      throw error;
    }
  }

  /**
   * Exécute une requête SELECT unique
   */
  async get(sql, params = []) {
    if (!this.isConnected) {
      await this.init();
    }

    try {
      const result = await this.pool.query(sql, params);
      return result.rows[0] || null;
    } catch (error) {
      logManager.error('Erreur requête GET', { sql, params, error: error.message });
      throw error;
    }
  }

  /**
   * Exécute une requête SELECT multiple
   */
  async all(sql, params = []) {
    if (!this.isConnected) {
      await this.init();
    }

    try {
      const result = await this.pool.query(sql, params);
      return result.rows;
    } catch (error) {
      logManager.error('Erreur requête ALL', { sql, params, error: error.message });
      throw error;
    }
  }

  /**
   * Exécute une requête INSERT/UPDATE/DELETE
   */
  async run(sql, params = []) {
    if (!this.isConnected) {
      await this.init();
    }

    try {
      const result = await this.pool.query(sql, params);
      return {
        lastID: result.rows &amp;&amp; result.rows.length > 0 ? result.rows[0]?.id || null : null,
        changes: result.rowCount || 0,
        rows: result.rows || []
      };
    } catch (error) {
      logManager.error('Erreur requête RUN', { sql, params, error: error.message });
      throw error;
    }
  }

  /**
   * Exécute une transaction avec callback
   */
  async transaction(callback) {
    if (!this.isConnected) {
      await this.init();
    }

    const client = await this.pool.connect();
    
    try {
      await client.query('BEGIN');
      
      // Crée un objet de transaction avec les méthodes de base
      const transaction = {
        get: async (sql, params = []) => {
          const result = await client.query(sql, params);
          return result.rows[0] || null;
        },
        all: async (sql, params = []) => {
          const result = await client.query(sql, params);
          return result.rows;
        },
        run: async (sql, params = []) => {
          const result = await client.query(sql, params);
          return {
            lastID: result.rows[0]?.id || null,
            changes: result.rowCount,
            rows: result.rows
          };
        }
      };

      const result = await callback(transaction);
      await client.query('COMMIT');
      logManager.info('Transaction committée');
      return result;
      
    } catch (error) {
      await client.query('ROLLBACK');
      logManager.error('Erreur transaction', { error: error.message });
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Compte le nombre d'enregistrements
   */
  async count(table, where = '', params = []) {
    const sql = `SELECT COUNT(*) as count FROM ${table} ${where ? 'WHERE ' + where : ''}`;
    const result = await this.get(sql, params);
    return result.count;
  }

  /**
   * Vérifie si un enregistrement existe
   */
  async exists(table, where, params = []) {
    const count = await this.count(table, where, params);
    return count > 0;
  }

  /**
   * Récupère le dernier enregistrement inséré
   */
  async getLastInserted(table, orderColumn = 'id') {
    const sql = `SELECT * FROM ${table} ORDER BY ${orderColumn} DESC LIMIT 1`;
    return await this.get(sql);
  }

  /**
   * Pagination simple
   */
  async paginate(table, page = 1, limit = 10, where = '', params = [], orderBy = 'id DESC') {
    const offset = (page - 1) * limit;
    
    // Compte total
    const total = await this.count(table, where, params);
    
    // Données paginées
    const sql = `
      SELECT * FROM ${table} 
      ${where ? 'WHERE ' + where : ''} 
      ORDER BY ${orderBy} 
      LIMIT ? OFFSET ?
    `;
    const rows = await this.all(sql, [...params, limit, offset]);

    return {
      data: rows,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
        hasNext: page &lt; Math.ceil(total / limit),
        hasPrev: page > 1
      }
    };
  }

  /**
   * Optimisation de la base de données PostgreSQL
   */
  async optimize() {
    try {
      await this.run('VACUUM ANALYZE');
      logManager.info('Optimisation base de données PostgreSQL terminée');
    } catch (error) {
      logManager.error('Erreur optimisation base de données', { error: error.message });
      throw error;
    }
  }

  /**
   * Statistiques de la base de données PostgreSQL
   */
  async getStats() {
    try {
      const tables = await this.all(`
        SELECT table_name as name 
        FROM information_schema.tables 
        WHERE table_schema = 'public'
      `);
      
      const stats = {};
      
      for (const table of tables) {
        const count = await this.count(table.name);
        stats[table.name] = count;
      }

      // Taille de la base de données
      const sizeResult = await this.get(`
        SELECT pg_size_pretty(pg_database_size(current_database())) as size
      `);
      
      return {
        tables: stats,
        totalTables: tables.length,
        databaseSize: sizeResult?.size || 'N/A'
      };
    } catch (error) {
      logManager.error('Erreur récupération statistiques', { error: error.message });
      throw error;
    }
  }

  /**
   * Vérifie si la base de données est accessible
   */
  async isHealthy() {
    try {
      if (!this.isConnected) {
        return false;
      }
      
      const result = await this.pool.query('SELECT 1 as healthy');
      return result.rows[0]?.healthy === 1;
    } catch (error) {
      logManager.error('Erreur vérification santé base de données', { error: error.message });
      return false;
    }
  }

  /**
   * Retourne les statistiques de la pool de connexions
   */
  getPoolStats() {
    if (!this.pool) {
      return null;
    }

    return {
      total: this.pool.totalCount,
      idle: this.pool.idleCount,
      waiting: this.pool.waitingCount
    };
  }

  /**
   * Ferme toutes les connexions PostgreSQL
   */
  async close() {
    if (this.pool) {
      try {
        await this.pool.end();
        this.isConnected = false;
        logManager.info('Connexions PostgreSQL fermées');
      } catch (error) {
        logManager.error('Erreur fermeture connexions PostgreSQL', { error: error.message });
      }
    }
  }

  /**
   * Getter pour l'instance de pool PostgreSQL (si besoin)
   */
  get instance() {
    return this.pool;
  }

  /**
   * Vérifie si la connexion est active
   */
  get connected() {
    return this.isConnected;
  }
}

// Export singleton
module.exports = new DatabaseManager();</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Actualite.html">Actualite</a></li><li><a href="AdminController.html">AdminController</a></li><li><a href="AdminOracleService.html">AdminOracleService</a></li><li><a href="AnonymousTokenService.html">AnonymousTokenService</a></li><li><a href="AuthentificationController.html">AuthentificationController</a></li><li><a href="BaseController.html">BaseController</a></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="BasePdfKitService.html">BasePdfKitService</a></li><li><a href="BaseService.html">BaseService</a></li><li><a href="CharacterSheetDocument.html">CharacterSheetDocument</a></li><li><a href="ClassPlanDocument.html">ClassPlanDocument</a></li><li><a href="DocumentFactory.html">DocumentFactory</a></li><li><a href="DonationController.html">DonationController</a></li><li><a href="EmailService.html">EmailService</a></li><li><a href="EmailTemplate.html">EmailTemplate</a></li><li><a href="EngrenagesTheme.html">EngrenagesTheme</a></li><li><a href="GenericDocument.html">GenericDocument</a></li><li><a href="HomeController.html">HomeController</a></li><li><a href="MarkdownService.html">MarkdownService</a></li><li><a href="Metro2033Theme.html">Metro2033Theme</a></li><li><a href="MonsterheartsTheme.html">MonsterheartsTheme</a></li><li><a href="Newsletter.html">Newsletter</a></li><li><a href="NewsletterService.html">NewsletterService</a></li><li><a href="Oracle.html">Oracle</a></li><li><a href="OracleController.html">OracleController</a></li><li><a href="OracleItem.html">OracleItem</a></li><li><a href="OracleService.html">OracleService</a></li><li><a href="Pdf.html">Pdf</a></li><li><a href="PdfController.html">PdfController</a></li><li><a href="PdfKitService.html">PdfKitService</a></li><li><a href="PdfService.html">PdfService</a></li><li><a href="Personnage.html">Personnage</a></li><li><a href="PersonnageController.html">PersonnageController</a></li><li><a href="PersonnageService.html">PersonnageService</a></li><li><a href="ShareService.html">ShareService</a></li><li><a href="SystemCardViewModel.html">SystemCardViewModel</a></li><li><a href="SystemRightsService.html">SystemRightsService</a></li><li><a href="SystemService.html">SystemService</a></li><li><a href="SystemTheme.html">SystemTheme</a></li><li><a href="SystemThemeService.html">SystemThemeService</a></li><li><a href="Temoignage.html">Temoignage</a></li><li><a href="TemoignageService.html">TemoignageService</a></li><li><a href="TemplateService.html">TemplateService</a></li><li><a href="Utilisateur.html">Utilisateur</a></li><li><a href="UtilisateurService.html">UtilisateurService</a></li><li><a href="ZombiologyTheme.html">ZombiologyTheme</a></li></ul><h3>Global</h3><ul><li><a href="global.html#compareVersions">compareVersions</a></li><li><a href="global.html#createMigrationsTable">createMigrationsTable</a></li><li><a href="global.html#createTables">createTables</a></li><li><a href="global.html#executeMigration">executeMigration</a></li><li><a href="global.html#getCurrentVersion">getCurrentVersion</a></li><li><a href="global.html#getExecutedMigrations">getExecutedMigrations</a></li><li><a href="global.html#getMigrationStatus">getMigrationStatus</a></li><li><a href="global.html#getVersionsToMigrate">getVersionsToMigrate</a></li><li><a href="global.html#initializeDatabase">initializeDatabase</a></li><li><a href="global.html#isDatabaseInitialized">isDatabaseInitialized</a></li><li><a href="global.html#markMigrationExecuted">markMigrationExecuted</a></li><li><a href="global.html#migrateDatabase">migrateDatabase</a></li><li><a href="global.html#migrateToLatest">migrateToLatest</a></li><li><a href="global.html#migrateToVersion">migrateToVersion</a></li><li><a href="global.html#migrations">migrations</a></li><li><a href="global.html#resetDatabase">resetDatabase</a></li><li><a href="global.html#rollbackMigration">rollbackMigration</a></li><li><a href="global.html#updateAppVersion">updateAppVersion</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Aug 05 2025 11:22:29 GMT+0200 (heure d’été d’Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
