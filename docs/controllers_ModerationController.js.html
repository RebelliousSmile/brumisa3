<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: controllers/ModerationController.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: controllers/ModerationController.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const BaseController = require('./BaseController');
const Document = require('../models/Document');
const DocumentModerationHistorique = require('../models/DocumentModerationHistorique');

/**
 * Contrôleur pour les fonctionnalités de modération
 * Implémente la modération a posteriori selon FONCTIONNALITES/06-administration.md
 */
class ModerationController extends BaseController {
    constructor() {
        super('ModerationController');
    }

    /**
     * Lister les documents en attente de modération
     * GET /api/admin/moderation/documents-en-attente
     */
    documentsEnAttente = this.wrapAsync(async (req, res) => {
        this.verifierPermissions(req, 'ADMIN');
        const pagination = this.extrairePagination(req);
        
        // Documents publics non encore modérés
        const conditions = {
            est_public: true,
            statut_moderation: 'EN_ATTENTE'
        };
        
        const documents = await Document.findAll(conditions, {
            orderBy: [['created_at', 'ASC']], // Les plus anciens en premier
            limit: pagination.limite,
            offset: pagination.offset
        });
        
        const total = await Document.count(conditions);
        
        return this.repondrePagine(res, documents, {
            ...pagination,
            total
        }, 'Documents en attente récupérés');
    });

    /**
     * Approuver un document
     * POST /api/admin/moderation/documents/:id/approuver
     */
    approuverDocument = this.wrapAsync(async (req, res) => {
        this.validerParametres(req, ['id']);
        const utilisateur = this.verifierPermissions(req, 'ADMIN');
        
        const documentId = parseInt(req.params.id);
        const { commentaire_admin } = req.body;
        
        const document = await Document.findById(documentId);
        if (!document) {
            return this.repondreErreur(res, 404, 'Document non trouvé', 'not_found');
        }
        
        if (document.statut_moderation !== 'EN_ATTENTE') {
            return this.repondreErreur(res, 400, 'Ce document a déjà été modéré', 'validation');
        }
        
        // Mettre à jour le statut du document
        await Document.update(documentId, {
            statut_moderation: 'APPROUVE',
            modere_le: new Date(),
            modere_par: utilisateur.id
        });
        
        // Enregistrer l'historique de modération
        await DocumentModerationHistorique.create({
            document_id: documentId,
            moderateur_id: utilisateur.id,
            action: 'APPROBATION',
            commentaire: commentaire_admin || 'Document approuvé',
            statut_avant: 'EN_ATTENTE',
            statut_apres: 'APPROUVE'
        });
        
        this.logger.info('Document approuvé', {
            document_id: documentId,
            moderateur_id: utilisateur.id,
            commentaire: commentaire_admin
        });
        
        return this.repondreSucces(res, null, 'Document approuvé avec succès');
    });

    /**
     * Rejeter un document
     * POST /api/admin/moderation/documents/:id/rejeter
     */
    rejeterDocument = this.wrapAsync(async (req, res) => {
        this.validerParametres(req, ['id']);
        const utilisateur = this.verifierPermissions(req, 'ADMIN');
        
        const documentId = parseInt(req.params.id);
        const { motif, commentaire_admin } = req.body;
        
        if (!motif) {
            const erreur = new Error('Le motif de rejet est obligatoire');
            erreur.name = 'ValidationError';
            throw erreur;
        }
        
        const document = await Document.findById(documentId);
        if (!document) {
            return this.repondreErreur(res, 404, 'Document non trouvé', 'not_found');
        }
        
        if (document.statut_moderation !== 'EN_ATTENTE') {
            return this.repondreErreur(res, 400, 'Ce document a déjà été modéré', 'validation');
        }
        
        // Mettre à jour le statut du document
        await Document.update(documentId, {
            statut_moderation: 'REJETE',
            est_public: false, // Retirer de la visibilité publique
            modere_le: new Date(),
            modere_par: utilisateur.id
        });
        
        // Enregistrer l'historique de modération
        await DocumentModerationHistorique.create({
            document_id: documentId,
            moderateur_id: utilisateur.id,
            action: 'REJET',
            motif,
            commentaire: commentaire_admin,
            statut_avant: 'EN_ATTENTE',
            statut_apres: 'REJETE'
        });
        
        this.logger.info('Document rejeté', {
            document_id: documentId,
            moderateur_id: utilisateur.id,
            motif,
            commentaire: commentaire_admin
        });
        
        return this.repondreSucces(res, null, 'Document rejeté avec succès');
    });

    /**
     * Mettre en avant un document approuvé
     * POST /api/admin/moderation/documents/:id/mettre-en-avant
     */
    mettreEnAvant = this.wrapAsync(async (req, res) => {
        this.validerParametres(req, ['id']);
        const utilisateur = this.verifierPermissions(req, 'ADMIN');
        
        const documentId = parseInt(req.params.id);
        const { commentaire_admin } = req.body;
        
        const document = await Document.findById(documentId);
        if (!document) {
            return this.repondreErreur(res, 404, 'Document non trouvé', 'not_found');
        }
        
        if (document.statut_moderation !== 'APPROUVE') {
            return this.repondreErreur(res, 400, 'Seuls les documents approuvés peuvent être mis en avant', 'validation');
        }
        
        // Mettre à jour le statut du document
        await Document.update(documentId, {
            est_mis_en_avant: true,
            mis_en_avant_le: new Date(),
            mis_en_avant_par: utilisateur.id
        });
        
        // Enregistrer l'historique de modération
        await DocumentModerationHistorique.create({
            document_id: documentId,
            moderateur_id: utilisateur.id,
            action: 'MISE_EN_AVANT',
            commentaire: commentaire_admin || 'Document mis en avant',
            statut_avant: 'APPROUVE',
            statut_apres: 'APPROUVE'
        });
        
        this.logger.info('Document mis en avant', {
            document_id: documentId,
            moderateur_id: utilisateur.id,
            commentaire: commentaire_admin
        });
        
        return this.repondreSucces(res, null, 'Document mis en avant avec succès');
    });

    /**
     * Retirer la mise en avant d'un document
     * POST /api/admin/moderation/documents/:id/retirer-mise-en-avant
     */
    retirerMiseEnAvant = this.wrapAsync(async (req, res) => {
        this.validerParametres(req, ['id']);
        const utilisateur = this.verifierPermissions(req, 'ADMIN');
        
        const documentId = parseInt(req.params.id);
        const { commentaire_admin } = req.body;
        
        const document = await Document.findById(documentId);
        if (!document) {
            return this.repondreErreur(res, 404, 'Document non trouvé', 'not_found');
        }
        
        if (!document.est_mis_en_avant) {
            return this.repondreErreur(res, 400, 'Ce document n\'est pas mis en avant', 'validation');
        }
        
        // Mettre à jour le statut du document
        await Document.update(documentId, {
            est_mis_en_avant: false,
            mis_en_avant_le: null,
            mis_en_avant_par: null
        });
        
        // Enregistrer l'historique de modération
        await DocumentModerationHistorique.create({
            document_id: documentId,
            moderateur_id: utilisateur.id,
            action: 'RETRAIT_MISE_EN_AVANT',
            commentaire: commentaire_admin || 'Mise en avant retirée',
            statut_avant: 'APPROUVE',
            statut_apres: 'APPROUVE'
        });
        
        this.logger.info('Mise en avant retirée', {
            document_id: documentId,
            moderateur_id: utilisateur.id,
            commentaire: commentaire_admin
        });
        
        return this.repondreSucces(res, null, 'Mise en avant retirée avec succès');
    });

    /**
     * Signaler un document (par les utilisateurs)
     * POST /api/documents/:id/signaler
     */
    signalerDocument = this.wrapAsync(async (req, res) => {
        this.validerParametres(req, ['id']);
        const utilisateur = this.verifierPermissions(req, 'UTILISATEUR');
        
        const documentId = parseInt(req.params.id);
        const { motif, commentaire } = req.body;
        
        if (!motif) {
            const erreur = new Error('Le motif de signalement est obligatoire');
            erreur.name = 'ValidationError';
            throw erreur;
        }
        
        const document = await Document.findById(documentId);
        if (!document) {
            return this.repondreErreur(res, 404, 'Document non trouvé', 'not_found');
        }
        
        if (!document.est_public) {
            return this.repondreErreur(res, 400, 'Seuls les documents publics peuvent être signalés', 'validation');
        }
        
        // Vérifier que l'utilisateur n'a pas déjà signalé ce document
        const signalementExistant = await DocumentModerationHistorique.findOne({
            document_id: documentId,
            moderateur_id: utilisateur.id,
            action: 'SIGNALEMENT'
        });
        
        if (signalementExistant) {
            return this.repondreErreur(res, 409, 'Vous avez déjà signalé ce document', 'conflit');
        }
        
        // Enregistrer le signalement
        await DocumentModerationHistorique.create({
            document_id: documentId,
            moderateur_id: utilisateur.id,
            action: 'SIGNALEMENT',
            motif,
            commentaire,
            statut_avant: document.statut_moderation,
            statut_apres: document.statut_moderation
        });
        
        this.logger.info('Document signalé', {
            document_id: documentId,
            utilisateur_id: utilisateur.id,
            motif,
            commentaire
        });
        
        return this.repondreSucces(res, null, 'Document signalé avec succès');
    });

    /**
     * Obtenir l'historique de modération d'un document
     * GET /api/admin/moderation/documents/:id/historique
     */
    obtenirHistoriqueDocument = this.wrapAsync(async (req, res) => {
        this.validerParametres(req, ['id']);
        this.verifierPermissions(req, 'ADMIN');
        
        const documentId = parseInt(req.params.id);
        const pagination = this.extrairePagination(req);
        
        const historique = await DocumentModerationHistorique.findAll({
            document_id: documentId
        }, {
            orderBy: [['created_at', 'DESC']],
            limit: pagination.limite,
            offset: pagination.offset
        });
        
        const total = await DocumentModerationHistorique.count({
            document_id: documentId
        });
        
        return this.repondrePagine(res, historique, {
            ...pagination,
            total
        }, 'Historique de modération récupéré');
    });

    /**
     * Obtenir les statistiques de modération
     * GET /api/admin/moderation/statistiques
     */
    obtenirStatistiques = this.wrapAsync(async (req, res) => {
        this.verifierPermissions(req, 'ADMIN');
        
        // Statistiques globales
        const totalDocuments = await Document.count({ est_public: true });
        const enAttente = await Document.count({ 
            est_public: true, 
            statut_moderation: 'EN_ATTENTE' 
        });
        const approuves = await Document.count({ 
            est_public: true, 
            statut_moderation: 'APPROUVE' 
        });
        const rejetes = await Document.count({ 
            est_public: true, 
            statut_moderation: 'REJETE' 
        });
        const misEnAvant = await Document.count({ 
            est_public: true, 
            est_mis_en_avant: true 
        });
        
        // Statistiques par action
        const actionsStats = await DocumentModerationHistorique.getStatistiquesActions();
        
        // Signalements récents (30 derniers jours)
        const signalements = await DocumentModerationHistorique.count({
            action: 'SIGNALEMENT',
            created_at: { gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }
        });
        
        const statistiques = {
            documents: {
                total: totalDocuments,
                en_attente: enAttente,
                approuves,
                rejetes,
                mis_en_avant: misEnAvant,
                taux_approbation: totalDocuments > 0 ? (approuves / (approuves + rejetes) * 100).toFixed(1) : 0
            },
            actions: actionsStats,
            signalements_30j: signalements
        };
        
        return this.repondreSucces(res, statistiques, 'Statistiques de modération récupérées');
    });

    /**
     * Lister les documents mis en avant
     * GET /api/communaute/:systeme/documents-mis-en-avant
     */
    documentsMisEnAvant = this.wrapAsync(async (req, res) => {
        this.validerParametres(req, ['systeme']);
        const { systeme } = req.params;
        const pagination = this.extrairePagination(req);
        const { type } = req.query;
        
        const conditions = {
            systeme,
            est_public: true,
            est_mis_en_avant: true,
            statut_moderation: 'APPROUVE',
            ...(type &amp;&amp; { type })
        };
        
        const documents = await Document.findAll(conditions, {
            orderBy: [['mis_en_avant_le', 'DESC']],
            limit: pagination.limite,
            offset: pagination.offset
        });
        
        const total = await Document.count(conditions);
        
        return this.repondrePagine(res, documents, {
            ...pagination,
            total
        }, 'Documents mis en avant récupérés');
    });
}

module.exports = ModerationController;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Actualite.html">Actualite</a></li><li><a href="AdminController.html">AdminController</a></li><li><a href="AdminOracleService.html">AdminOracleService</a></li><li><a href="AnonymousTokenService.html">AnonymousTokenService</a></li><li><a href="AuthentificationController.html">AuthentificationController</a></li><li><a href="BaseController.html">BaseController</a></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="BasePdfKitService.html">BasePdfKitService</a></li><li><a href="BaseService.html">BaseService</a></li><li><a href="CacheService.html">CacheService</a></li><li><a href="CharacterSheetDocument.html">CharacterSheetDocument</a></li><li><a href="ClassPlanDocument.html">ClassPlanDocument</a></li><li><a href="DangerDocument.html">DangerDocument</a></li><li><a href="DemandeChangementEmail.html">DemandeChangementEmail</a></li><li><a href="Document.html">Document</a></li><li><a href="DocumentFactory.html">DocumentFactory</a></li><li><a href="DocumentModerationHistorique.html">DocumentModerationHistorique</a></li><li><a href="DocumentModerationService.html">DocumentModerationService</a></li><li><a href="DocumentSystemeJeu.html">DocumentSystemeJeu</a></li><li><a href="DocumentVote.html">DocumentVote</a></li><li><a href="DonationController.html">DonationController</a></li><li><a href="EmailService.html">EmailService</a></li><li><a href="EmailTemplate.html">EmailTemplate</a></li><li><a href="EngrenagesTheme.html">EngrenagesTheme</a></li><li><a href="GenericDocument.html">GenericDocument</a></li><li><a href="GroupDocument.html">GroupDocument</a></li><li><a href="HomeController.html">HomeController</a></li><li><a href="LoggingService.html">LoggingService</a></li><li><a href="MaintenanceWorker.html">MaintenanceWorker</a></li><li><a href="MarkdownService.html">MarkdownService</a></li><li><a href="Metro2033Theme.html">Metro2033Theme</a></li><li><a href="MistEngineTheme.html">MistEngineTheme</a></li><li><a href="ModerationController.html">ModerationController</a></li><li><a href="MonsterheartsTheme.html">MonsterheartsTheme</a></li><li><a href="Newsletter.html">Newsletter</a></li><li><a href="NewsletterService.html">NewsletterService</a></li><li><a href="Oracle.html">Oracle</a></li><li><a href="OracleController.html">OracleController</a></li><li><a href="OracleItem.html">OracleItem</a></li><li><a href="OracleService.html">OracleService</a></li><li><a href="OrganizationDocument.html">OrganizationDocument</a></li><li><a href="Pdf.html">Pdf</a></li><li><a href="PdfController.html">PdfController</a></li><li><a href="PdfKitService.html">PdfKitService</a></li><li><a href="PdfService.html">PdfService</a></li><li><a href="PerformanceMiddleware.html">PerformanceMiddleware</a></li><li><a href="PerformanceMonitoringService.html">PerformanceMonitoringService</a></li><li><a href="Personnage.html">Personnage</a></li><li><a href="PersonnageController.html">PersonnageController</a></li><li><a href="PersonnageService.html">PersonnageService</a></li><li><a href="ProductionApp.html">ProductionApp</a></li><li><a href="QueueService.html">QueueService</a></li><li><a href="QueueWorker.html">QueueWorker</a></li><li><a href="RgpdConsentement.html">RgpdConsentement</a></li><li><a href="RgpdService.html">RgpdService</a></li><li><a href="SecurityService.html">SecurityService</a></li><li><a href="ShareService.html">ShareService</a></li><li><a href="SystemCardViewModel.html">SystemCardViewModel</a></li><li><a href="SystemMaintenanceService.html">SystemMaintenanceService</a></li><li><a href="SystemRightsService.html">SystemRightsService</a></li><li><a href="SystemService.html">SystemService</a></li><li><a href="SystemTheme.html">SystemTheme</a></li><li><a href="SystemThemeService.html">SystemThemeService</a></li><li><a href="SystemeJeu.html">SystemeJeu</a></li><li><a href="Temoignage.html">Temoignage</a></li><li><a href="TemoignageService.html">TemoignageService</a></li><li><a href="TemplateService.html">TemplateService</a></li><li><a href="TownDocument.html">TownDocument</a></li><li><a href="Utilisateur.html">Utilisateur</a></li><li><a href="UtilisateurService.html">UtilisateurService</a></li><li><a href="VoteController.html">VoteController</a></li><li><a href="VoteService.html">VoteService</a></li><li><a href="ZombiologyTheme.html">ZombiologyTheme</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Joi">Joi</a></li><li><a href="global.html#asyncHandler">asyncHandler</a></li><li><a href="global.html#auth">auth</a></li><li><a href="global.html#compareVersions">compareVersions</a></li><li><a href="global.html#createError">createError</a></li><li><a href="global.html#createMigrationsTable">createMigrationsTable</a></li><li><a href="global.html#createTables">createTables</a></li><li><a href="global.html#database">database</a></li><li><a href="global.html#executeMigration">executeMigration</a></li><li><a href="global.html#getCurrentVersion">getCurrentVersion</a></li><li><a href="global.html#getErrorMessage">getErrorMessage</a></li><li><a href="global.html#getExecutedMigrations">getExecutedMigrations</a></li><li><a href="global.html#getMigrationStatus">getMigrationStatus</a></li><li><a href="global.html#getVersionsToMigrate">getVersionsToMigrate</a></li><li><a href="global.html#handleError">handleError</a></li><li><a href="global.html#handleNotFound">handleNotFound</a></li><li><a href="global.html#initializeDatabase">initializeDatabase</a></li><li><a href="global.html#isDatabaseInitialized">isDatabaseInitialized</a></li><li><a href="global.html#logger">logger</a></li><li><a href="global.html#markMigrationExecuted">markMigrationExecuted</a></li><li><a href="global.html#migrateDatabase">migrateDatabase</a></li><li><a href="global.html#migrateToLatest">migrateToLatest</a></li><li><a href="global.html#migrateToVersion">migrateToVersion</a></li><li><a href="global.html#migrations">migrations</a></li><li><a href="global.html#optionalAuth">optionalAuth</a></li><li><a href="global.html#path">path</a></li><li><a href="global.html#requireAdmin">requireAdmin</a></li><li><a href="global.html#requireAuth">requireAuth</a></li><li><a href="global.html#requirePremium">requirePremium</a></li><li><a href="global.html#resetDatabase">resetDatabase</a></li><li><a href="global.html#rollbackMigration">rollbackMigration</a></li><li><a href="global.html#schemas">schemas</a></li><li><a href="global.html#updateAppVersion">updateAppVersion</a></li><li><a href="global.html#validateFiles">validateFiles</a></li><li><a href="global.html#validateRequest">validateRequest</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Aug 08 2025 18:17:39 GMT+0200 (heure d’été d’Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
