<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/UtilisateurService.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/UtilisateurService.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const BaseService = require('./BaseService');
const Utilisateur = require('../models/Utilisateur');
const crypto = require('crypto');

/**
 * Service pour la gestion des utilisateurs
 */
class UtilisateurService extends BaseService {
    constructor() {
        super('UtilisateurService');
        this.utilisateurModel = new Utilisateur();
    }

    /**
     * Crée un nouvel utilisateur
     */
    async creer(donnees) {
        try {
            // Valider les données
            this.validerDonnees(donnees);
            
            // Vérifier que l'email n'existe pas déjà
            const utilisateurExistant = await this.obtenirParEmail(donnees.email);
            if (utilisateurExistant) {
                throw new Error('Un utilisateur avec cet email existe déjà');
            }
            
            // Préparer les données (conversion camelCase vers snake_case pour la DB)
            const donneesCompletes = {
                nom: donnees.nom.trim(),
                email: donnees.email.toLowerCase().trim(),
                mot_de_passe: donnees.motDePasse || donnees.mot_de_passe, // Support des deux formats
                role: donnees.role || 'UTILISATEUR',
                actif: true,
                date_creation: new Date(),
                derniere_connexion: new Date()
            };

            // Ajouter les champs premium si fournis
            if (donnees.type_compte) {
                donneesCompletes.type_compte = donnees.type_compte;
            }
            if (donnees.date_premium) {
                donneesCompletes.date_premium = donnees.date_premium;
            }
            if (donnees.montant_don_total !== undefined) {
                donneesCompletes.montant_don_total = donnees.montant_don_total;
            }
            if (donnees.compte_don_temporaire !== undefined) {
                donneesCompletes.compte_don_temporaire = donnees.compte_don_temporaire;
            }
            
            // Créer l'utilisateur
            const utilisateur = await this.utilisateurModel.create(donneesCompletes);
            
            this.logger.info('Utilisateur créé:', { 
                id: utilisateur.id, 
                email: utilisateur.email,
                role: utilisateur.role 
            });
            
            return utilisateur;
            
        } catch (erreur) {
            this.logger.error('Erreur lors de la création utilisateur:', erreur);
            throw erreur;
        }
    }

    /**
     * Obtient un utilisateur par ID
     */
    async obtenirParId(id) {
        try {
            return await this.utilisateurModel.obtenirParId(id);
        } catch (erreur) {
            this.logger.error(`Erreur lors de la récupération utilisateur ${id}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Obtient un utilisateur par email
     */
    async obtenirParEmail(email) {
        try {
            return await this.utilisateurModel.obtenirParEmail(email.toLowerCase().trim());
        } catch (erreur) {
            this.logger.error(`Erreur lors de la récupération utilisateur par email ${email}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Met à jour un utilisateur
     */
    async mettreAJour(id, donnees) {
        try {
            // Vérifier que l'utilisateur existe
            const utilisateurExistant = await this.obtenirParId(id);
            if (!utilisateurExistant) {
                throw new Error('Utilisateur non trouvé');
            }
            
            // Filtrer les données autorisées
            const donneesAutorisees = this.filtrerDonneesMAJ(donnees);
            
            // Valider les données
            if (Object.keys(donneesAutorisees).length === 0) {
                throw new Error('Aucune donnée valide à mettre à jour');
            }
            
            this.validerDonnees({ ...utilisateurExistant, ...donneesAutorisees }, true);
            
            // Ajouter la date de modification
            donneesAutorisees.date_modification = new Date();
            
            // Mettre à jour
            const utilisateurMisAJour = await this.utilisateurModel.update(id, donneesAutorisees);
            
            this.logger.info('Utilisateur mis à jour:', { 
                id: utilisateurMisAJour.id, 
                champs: Object.keys(donneesAutorisees) 
            });
            
            return utilisateurMisAJour;
            
        } catch (erreur) {
            this.logger.error(`Erreur lors de la mise à jour utilisateur ${id}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Met à jour le rôle d'un utilisateur
     */
    async mettreAJourRole(id, nouveauRole) {
        try {
            // Valider le rôle
            const rolesValides = ['UTILISATEUR', 'PREMIUM', 'ADMIN'];
            if (!rolesValides.includes(nouveauRole)) {
                throw new Error('Rôle invalide');
            }
            
            const utilisateur = await this.mettreAJour(id, { role: nouveauRole });
            
            this.logger.info('Rôle utilisateur mis à jour:', { 
                id, 
                nouveau_role: nouveauRole 
            });
            
            return utilisateur;
            
        } catch (erreur) {
            this.logger.error(`Erreur lors de la mise à jour du rôle ${id}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Met à jour la dernière connexion
     */
    async mettreAJourDerniereConnexion(id) {
        try {
            return await this.mettreAJour(id, { 
                derniere_connexion: new Date() 
            });
        } catch (erreur) {
            this.logger.error(`Erreur lors de la mise à jour dernière connexion ${id}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Désactive un utilisateur
     */
    async desactiver(id) {
        try {
            const utilisateur = await this.mettreAJour(id, { actif: false });
            
            this.logger.info('Utilisateur désactivé:', { id });
            
            return utilisateur;
            
        } catch (erreur) {
            this.logger.error(`Erreur lors de la désactivation utilisateur ${id}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Réactive un utilisateur
     */
    async reactiver(id) {
        try {
            const utilisateur = await this.mettreAJour(id, { actif: true });
            
            this.logger.info('Utilisateur réactivé:', { id });
            
            return utilisateur;
            
        } catch (erreur) {
            this.logger.error(`Erreur lors de la réactivation utilisateur ${id}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Supprime un utilisateur (soft delete)
     */
    async supprimer(id) {
        try {
            // Vérifier que l'utilisateur existe
            const utilisateur = await this.obtenirParId(id);
            if (!utilisateur) {
                throw new Error('Utilisateur non trouvé');
            }
            
            // Soft delete : désactiver et anonymiser
            const donneesAnonymisees = {
                email: `deleted_${id}@example.com`,
                nom: 'Utilisateur supprimé',
                actif: false,
                date_suppression: new Date()
            };
            
            await this.mettreAJour(id, donneesAnonymisees);
            
            this.logger.info('Utilisateur supprimé (soft delete):', { 
                id, 
                email_original: utilisateur.email 
            });
            
            return true;
            
        } catch (erreur) {
            this.logger.error(`Erreur lors de la suppression utilisateur ${id}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Liste les utilisateurs (admin uniquement)
     */
    async lister(filtres = {}, pagination = {}) {
        try {
            const conditions = [];
            const valeurs = [];
            
            // Filtres optionnels
            if (filtres.role) {
                conditions.push('role = ?');
                valeurs.push(filtres.role);
            }
            
            if (filtres.actif !== undefined) {
                conditions.push('actif = ?');
                valeurs.push(filtres.actif);
            }
            
            if (filtres.recherche) {
                conditions.push('(nom ILIKE ? OR email ILIKE ?)');
                valeurs.push(`%${filtres.recherche}%`, `%${filtres.recherche}%`);
            }
            
            // Ne pas afficher les utilisateurs supprimés par défaut
            if (!filtres.inclure_supprimes) {
                conditions.push('date_suppression IS NULL');
            }
            
            const whereClause = conditions.length > 0 ? conditions.join(' AND ') : null;
            
            // Compter le total
            const total = await this.utilisateurModel.count(whereClause, valeurs);
            
            // Récupérer les utilisateurs avec pagination
            const offset = pagination.offset || 0;
            const limite = pagination.limite || 20;
            
            const utilisateurs = await this.utilisateurModel.findAll(
                whereClause, 
                valeurs, 
                'date_creation DESC', 
                limite
            );
            
            return { utilisateurs, total };
            
        } catch (erreur) {
            this.logger.error('Erreur lors de la liste des utilisateurs:', erreur);
            throw erreur;
        }
    }

    /**
     * Recherche d'utilisateurs
     */
    async rechercher(terme, options = {}) {
        try {
            const conditions = [
                'actif = ? AND date_suppression IS NULL',
                '(nom ILIKE ? OR email ILIKE ?)'
            ];
            const valeurs = [true, `%${terme}%`, `%${terme}%`];
            
            // Filtre par rôle si spécifié
            if (options.role) {
                conditions.push('role = ?');
                valeurs.push(options.role);
            }
            
            const limite = Math.min(options.limite || 10, 50);
            
            const utilisateurs = await this.utilisateurModel.findAll(
                conditions.join(' AND '),
                valeurs,
                'nom ASC',
                limite
            );
            
            // Ne retourner que les infos publiques
            return utilisateurs.map(user => ({
                id: user.id,
                nom: user.nom,
                email: user.email,
                role: user.role
            }));
            
        } catch (erreur) {
            this.logger.error('Erreur lors de la recherche d\'utilisateurs:', erreur);
            throw erreur;
        }
    }

    /**
     * Obtient les statistiques des utilisateurs
     */
    async obtenirStatistiques() {
        try {
            return await this.utilisateurModel.compterParRole();
        } catch (erreur) {
            this.logger.error('Erreur lors du calcul des statistiques:', erreur);
            throw erreur;
        }
    }

    /**
     * Authentifie un utilisateur avec email et mot de passe
     */
    async authentifier(email, motDePasse) {
        try {
            const utilisateur = await this.obtenirParEmail(email);
            console.log('=== DEBUG AUTHENTIFICATION ===');
            console.log('Utilisateur trouvé:', utilisateur ? 'OUI' : 'NON');
            if (utilisateur) {
                console.log('ID:', utilisateur.id);
                console.log('Email:', utilisateur.email);
                console.log('Mot de passe hashé présent:', !!utilisateur.mot_de_passe);
                console.log('Hash:', utilisateur.mot_de_passe ? utilisateur.mot_de_passe.substring(0, 50) + '...' : 'ABSENT');
            }
            
            if (!utilisateur) {
                console.log('ECHEC: Utilisateur non trouvé');
                return null;
            }
            
            if (!utilisateur.mot_de_passe) {
                console.log('ECHEC: Mot de passe hashé absent de la BDD');
                return null;
            }
            
            // Vérifier le mot de passe avec le modèle
            console.log('Vérification du mot de passe...');
            const motDePasseValide = await this.utilisateurModel.verifierMotDePasse(motDePasse, utilisateur.mot_de_passe);
            console.log('Mot de passe valide:', motDePasseValide);
            
            if (!motDePasseValide) {
                this.logger.warn('Tentative de connexion avec mot de passe incorrect:', { 
                    email,
                    utilisateur_id: utilisateur.id 
                });
                return null;
            }
            
            console.log('SUCCES: Authentification réussie');
            return utilisateur;
            
        } catch (erreur) {
            console.log('ERREUR:', erreur.message);
            this.logger.error('Erreur lors de l\'authentification:', erreur);
            throw erreur;
        }
    }

    /**
     * Met à jour le mot de passe d'un utilisateur
     */
    async mettreAJourMotDePasse(id, nouveauMotDePasse) {
        try {
            // Vérifier que l'utilisateur existe
            const utilisateur = await this.obtenirParId(id);
            if (!utilisateur) {
                throw new Error('Utilisateur non trouvé');
            }
            
            // Le modèle se charge du hachage automatiquement
            await this.mettreAJour(id, {
                mot_de_passe: nouveauMotDePasse,
                token_recuperation: null,
                token_expiration: null
            });
            
            this.logger.info('Mot de passe mis à jour:', { utilisateur_id: id });
            
            return true;
            
        } catch (erreur) {
            this.logger.error(`Erreur lors de la mise à jour du mot de passe ${id}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Génère un token de récupération de mot de passe
     */
    async genererTokenRecuperation(email) {
        try {
            const utilisateur = await this.obtenirParEmail(email);
            if (!utilisateur || !utilisateur.actif) {
                // Ne pas révéler si l'email existe ou non
                this.logger.warn('Tentative de récupération pour email inexistant:', { email });
                return null;
            }
            
            // Générer un token sécurisé
            const token = crypto.randomBytes(32).toString('hex');
            const expiration = new Date(Date.now() + 60 * 60 * 1000); // 1 heure
            
            await this.mettreAJour(utilisateur.id, {
                token_recuperation: token,
                token_expiration: expiration
            });
            
            this.logger.info('Token de récupération généré:', { 
                utilisateur_id: utilisateur.id 
            });
            
            return { token, expiration };
            
        } catch (erreur) {
            this.logger.error('Erreur lors de la génération du token:', erreur);
            throw erreur;
        }
    }

    /**
     * Valide un token de récupération
     */
    async validerTokenRecuperation(token) {
        try {
            const utilisateur = await this.utilisateurModel.obtenirParToken(token);
            
            if (!utilisateur || !utilisateur.token_expiration) {
                return null;
            }
            
            // Vérifier l'expiration
            if (new Date() > new Date(utilisateur.token_expiration)) {
                // Nettoyer le token expiré
                await this.mettreAJour(utilisateur.id, {
                    token_recuperation: null,
                    token_expiration: null
                });
                return null;
            }
            
            return utilisateur;
            
        } catch (erreur) {
            this.logger.error('Erreur lors de la validation du token:', erreur);
            throw erreur;
        }
    }

    /**
     * Nettoie les tokens expirés
     */
    async nettoyerTokensExpires() {
        try {
            const maintenant = new Date();
            // Pour l'instant, on fait une mise à jour manuelle des tokens expirés
            const { sql, params } = this.utilisateurModel.convertPlaceholders(
                `UPDATE utilisateurs SET token_recuperation = NULL, token_expiration = NULL WHERE token_expiration &lt; ?`,
                [maintenant.toISOString()]
            );
            const db = require('../database/db');
            const result = await db.run(sql, params);
            const nbNettoyes = result.rowCount || 0;
            
            this.logger.info(`${nbNettoyes} tokens expirés nettoyés`);
            return nbNettoyes;
            
        } catch (erreur) {
            this.logger.error('Erreur lors du nettoyage des tokens:', erreur);
            throw erreur;
        }
    }

    /**
     * Valide les données d'un utilisateur
     */
    validerDonnees(donnees, miseAJour = false) {
        const erreurs = [];
        
        // Validation du nom
        if (donnees.nom !== undefined) {
            if (!donnees.nom || donnees.nom.trim().length &lt; 2) {
                erreurs.push('Le nom doit contenir au moins 2 caractères');
            }
            if (donnees.nom.trim().length > 100) {
                erreurs.push('Le nom ne peut pas dépasser 100 caractères');
            }
        }
        
        // Validation de l'email
        if (donnees.email !== undefined) {
            if (!donnees.email || !this.validerFormatEmail(donnees.email)) {
                erreurs.push('Format email invalide');
            }
        }
        
        // Validation du rôle
        if (donnees.role !== undefined) {
            const rolesValides = ['UTILISATEUR', 'PREMIUM', 'ADMIN'];
            if (!rolesValides.includes(donnees.role)) {
                erreurs.push('Rôle invalide');
            }
        }
        
        // Champs requis pour création
        if (!miseAJour) {
            if (!donnees.nom) {
                erreurs.push('Le nom est requis');
            }
            if (!donnees.email) {
                erreurs.push('L\'email est requis');
            }
        }
        
        if (erreurs.length > 0) {
            const erreur = new Error(erreurs.join(', '));
            erreur.name = 'ValidationError';
            erreur.details = erreurs;
            throw erreur;
        }
    }

    /**
     * Filtre les données autorisées pour une mise à jour
     */
    filtrerDonneesMAJ(donnees) {
        const champsAutorises = [
            'nom', 'email', 'role', 'actif', 'derniere_connexion', 'mot_de_passe', 
            'token_recuperation', 'token_expiration', 'type_compte', 'date_premium', 
            'montant_don_total', 'compte_don_temporaire'
        ];
        const donneesFiltr = {};
        
        champsAutorises.forEach(champ => {
            if (donnees[champ] !== undefined) {
                donneesFiltr[champ] = donnees[champ];
            }
        });
        
        return donneesFiltr;
    }

    /**
     * Valide le format email
     */
    validerFormatEmail(email) {
        const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return regex.test(email);
    }

    /**
     * Obtient les utilisateurs récemment connectés
     */
    async obtenirUtilisateursRecents(limite = 10) {
        try {
            return await this.utilisateurModel.findAll(
                'actif = ? AND derniere_connexion IS NOT NULL',
                [true],
                'derniere_connexion DESC',
                limite
            );
        } catch (erreur) {
            this.logger.error('Erreur lors de la récupération des utilisateurs récents:', erreur);
            throw erreur;
        }
    }

    /**
     * Compte les utilisateurs par rôle
     */
    async compterParRole() {
        try {
            return await this.utilisateurModel.compterParRole();
        } catch (erreur) {
            this.logger.error('Erreur lors du comptage par rôle:', erreur);
            throw erreur;
        }
    }

    /**
     * Active le statut Premium pour un utilisateur après un don
     * @param {string} utilisateurId - ID de l'utilisateur
     * @param {number} montantDon - Montant du don en euros
     * @returns {Object} Utilisateur mis à jour
     */
    async activerPremium(utilisateurId, montantDon) {
        try {
            // Déterminer le nouveau rôle selon le montant
            let nouveauRole = 'PREMIUM';
            let typeCompte = 'PREMIUM';
            
            if (montantDon >= 10) {
                typeCompte = 'PREMIUM_VIP';
            }
            
            const utilisateur = await this.mettreAJour(utilisateurId, {
                role: nouveauRole,
                type_compte: typeCompte,
                date_premium: new Date(),
                montant_don_total: montantDon // Ou incrémenter si il existe déjà
            });
            
            this.logger.info('Premium activé:', { 
                utilisateur_id: utilisateurId, 
                montant: montantDon,
                type: typeCompte 
            });
            
            return utilisateur;
            
        } catch (erreur) {
            this.logger.error(`Erreur activation Premium ${utilisateurId}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Crée un compte Premium temporaire pour un donateur sans compte
     * @param {string} email - Email du donateur
     * @param {number} montantDon - Montant du don
     * @returns {Object} Nouvel utilisateur créé
     */
    async creerCompteDonateur(email, montantDon) {
        try {
            // Générer un mot de passe temporaire
            const motDePasseTemp = crypto.randomBytes(8).toString('hex');
            
            // Déterminer le type de compte
            let typeCompte = 'PREMIUM';
            let role = 'PREMIUM';
            
            if (montantDon >= 10) {
                typeCompte = 'PREMIUM_VIP';
            }
            
            const donneesCompte = {
                nom: `Donateur ${email.split('@')[0]}`,
                email: email,
                motDePasse: motDePasseTemp,
                role: role,
                type_compte: typeCompte,
                date_premium: new Date(),
                montant_don_total: montantDon,
                compte_don_temporaire: true // Flag pour identifier les comptes créés par don
            };
            
            const utilisateur = await this.creer(donneesCompte);
            
            this.logger.info('Compte donateur créé:', { 
                utilisateur_id: utilisateur.id,
                email: email,
                montant: montantDon,
                type: typeCompte,
                mot_de_passe_temp: motDePasseTemp
            });
            
            // TODO: Envoyer email avec mot de passe temporaire
            
            return {
                ...utilisateur,
                motDePasseTemporaire: motDePasseTemp
            };
            
        } catch (erreur) {
            this.logger.error(`Erreur création compte donateur ${email}:`, erreur);
            throw erreur;
        }
    }
}

module.exports = UtilisateurService;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Actualite.html">Actualite</a></li><li><a href="AdminController.html">AdminController</a></li><li><a href="AdminOracleService.html">AdminOracleService</a></li><li><a href="AnonymousTokenService.html">AnonymousTokenService</a></li><li><a href="AuthentificationController.html">AuthentificationController</a></li><li><a href="BaseController.html">BaseController</a></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="BasePdfKitService.html">BasePdfKitService</a></li><li><a href="BaseService.html">BaseService</a></li><li><a href="CharacterSheetDocument.html">CharacterSheetDocument</a></li><li><a href="ClassPlanDocument.html">ClassPlanDocument</a></li><li><a href="DocumentFactory.html">DocumentFactory</a></li><li><a href="DonationController.html">DonationController</a></li><li><a href="EmailService.html">EmailService</a></li><li><a href="EmailTemplate.html">EmailTemplate</a></li><li><a href="EngrenagesTheme.html">EngrenagesTheme</a></li><li><a href="GenericDocument.html">GenericDocument</a></li><li><a href="HomeController.html">HomeController</a></li><li><a href="MarkdownService.html">MarkdownService</a></li><li><a href="Metro2033Theme.html">Metro2033Theme</a></li><li><a href="MonsterheartsTheme.html">MonsterheartsTheme</a></li><li><a href="Newsletter.html">Newsletter</a></li><li><a href="NewsletterService.html">NewsletterService</a></li><li><a href="Oracle.html">Oracle</a></li><li><a href="OracleController.html">OracleController</a></li><li><a href="OracleItem.html">OracleItem</a></li><li><a href="OracleService.html">OracleService</a></li><li><a href="Pdf.html">Pdf</a></li><li><a href="PdfController.html">PdfController</a></li><li><a href="PdfKitService.html">PdfKitService</a></li><li><a href="PdfService.html">PdfService</a></li><li><a href="Personnage.html">Personnage</a></li><li><a href="PersonnageController.html">PersonnageController</a></li><li><a href="PersonnageService.html">PersonnageService</a></li><li><a href="ShareService.html">ShareService</a></li><li><a href="SystemRightsService.html">SystemRightsService</a></li><li><a href="SystemService.html">SystemService</a></li><li><a href="SystemTheme.html">SystemTheme</a></li><li><a href="Temoignage.html">Temoignage</a></li><li><a href="TemoignageService.html">TemoignageService</a></li><li><a href="TemplateService.html">TemplateService</a></li><li><a href="Utilisateur.html">Utilisateur</a></li><li><a href="UtilisateurService.html">UtilisateurService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#compareVersions">compareVersions</a></li><li><a href="global.html#createMigrationsTable">createMigrationsTable</a></li><li><a href="global.html#createTables">createTables</a></li><li><a href="global.html#executeMigration">executeMigration</a></li><li><a href="global.html#getCurrentVersion">getCurrentVersion</a></li><li><a href="global.html#getExecutedMigrations">getExecutedMigrations</a></li><li><a href="global.html#getMigrationStatus">getMigrationStatus</a></li><li><a href="global.html#getVersionsToMigrate">getVersionsToMigrate</a></li><li><a href="global.html#initializeDatabase">initializeDatabase</a></li><li><a href="global.html#isDatabaseInitialized">isDatabaseInitialized</a></li><li><a href="global.html#markMigrationExecuted">markMigrationExecuted</a></li><li><a href="global.html#migrateDatabase">migrateDatabase</a></li><li><a href="global.html#migrateToLatest">migrateToLatest</a></li><li><a href="global.html#migrateToVersion">migrateToVersion</a></li><li><a href="global.html#migrations">migrations</a></li><li><a href="global.html#resetDatabase">resetDatabase</a></li><li><a href="global.html#rollbackMigration">rollbackMigration</a></li><li><a href="global.html#updateAppVersion">updateAppVersion</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Jul 23 2025 17:42:32 GMT+0200 (heure d’été d’Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
