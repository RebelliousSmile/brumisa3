<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: models/BaseModel.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: models/BaseModel.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const db = require('../database/db');
const logManager = require('../utils/logManager');
const Joi = require('joi');

/**
 * Classe de base pour tous les modèles
 * Implémente les principes SOLID et DRY
 * 
 * RELATIONS SUPPORTÉES DANS L'ARCHITECTURE MVC-CS:
 * 
 * Les modèles implémentent des relations via des méthodes préfixées selon le pattern Active Record:
 * 
 * 1. **hasMany(model)** - Relation 1:N
 *    - Méthode: `get{Models}(parentId, filters)`
 *    - Exemple: `utilisateur.getPersonnages(userId)`
 *    - CASCADE: Dépend du modèle enfant
 * 
 * 2. **belongsTo(model)** - Relation N:1
 *    - Méthode: `get{Model}(childId)`
 *    - Exemple: `personnage.getUtilisateur(personnageId)`
 *    - CASCADE: SET NULL ou RESTRICT selon importance
 * 
 * 3. **hasOne(model)** - Relation 1:1 
 *    - Méthode: `get{Model}(parentId)`
 *    - Rare dans ce projet
 * 
 * STRATÉGIES DE CASCADE IMPLÉMENTÉES:
 * 
 * - **CASCADE**: Suppression en cascade pour données dépendantes
 *   - Votes, historiques de modération, consentements RGPD
 * 
 * - **SET NULL**: Préservation des données avec désassociation
 *   - Documents anonymes, historiques avec modérateur supprimé
 * 
 * - **RESTRICT**: Interdiction de suppression si dépendances
 *   - Systèmes JDR avec documents/personnages existants
 * 
 * CONTRAINTES D'INTÉGRITÉ APPLIQUÉES:
 * 
 * - **UNIQUE**: Un vote par utilisateur/document, clés composites
 * - **NOT NULL**: Relations obligatoires (personnages->utilisateur)
 * - **CHECK**: Validation des énumérations et valeurs
 * 
 * Voir architecture-models.md et migration 011_add_foreign_key_constraints.sql pour détails complets.
 */
class BaseModel {
  constructor(tableName, primaryKey = 'id') {
    this.tableName = tableName;
    this.primaryKey = primaryKey;
    this.fillable = []; // Champs autorisés en mass assignment
    this.guarded = []; // Champs protégés
    this.hidden = []; // Champs cachés lors de la sérialisation
    this.casts = {}; // Conversion automatique des types
    this.timestamps = true; // Gestion automatique created_at/updated_at
  }

  /**
   * Convertit les placeholders SQLite (?) vers PostgreSQL ($1, $2, etc.)
   */
  convertPlaceholders(sql, params) {
    let index = 1;
    const convertedSql = sql.replace(/\?/g, () => `$${index++}`);
    return { sql: convertedSql, params };
  }

  /**
   * Trouve un enregistrement par ID
   */
  async findById(id) {
    try {
      const { sql, params } = this.convertPlaceholders(
        `SELECT * FROM ${this.tableName} WHERE ${this.primaryKey} = ?`, 
        [id]
      );
      const row = await db.get(sql, params);
      return row ? this.castAttributes(row) : null;
    } catch (error) {
      if (logManager.logDatabaseOperation) {
        logManager.logDatabaseOperation('read', this.tableName, id, false, error);
      }
      throw error;
    }
  }

  /**
   * Trouve un enregistrement selon des critères
   */
  async findOne(where, params = []) {
    try {
      const { sql, params: convertedParams } = this.convertPlaceholders(
        `SELECT * FROM ${this.tableName} WHERE ${where} LIMIT 1`, 
        params
      );
      const row = await db.get(sql, convertedParams);
      return row ? this.castAttributes(row) : null;
    } catch (error) {
      if (logManager.logDatabaseOperation) {
        logManager.logDatabaseOperation('read', this.tableName, null, false, error);
      }
      throw error;
    }
  }

  /**
   * Trouve plusieurs enregistrements
   */
  async findAll(where = '', params = [], orderBy = '', limit = null) {
    try {
      let sql = `SELECT * FROM ${this.tableName}`;
      
      if (where) {
        sql += ` WHERE ${where}`;
      }
      
      if (orderBy) {
        sql += ` ORDER BY ${orderBy}`;
      }
      
      if (limit) {
        sql += ` LIMIT ${limit}`;
      }

      const { sql: convertedSql, params: convertedParams } = this.convertPlaceholders(sql, params);
      const rows = await db.all(convertedSql, convertedParams);
      return rows.map(row => this.castAttributes(row));
    } catch (error) {
      if (logManager.logDatabaseOperation) {
        logManager.logDatabaseOperation('read', this.tableName, null, false, error);
      }
      throw error;
    }
  }

  /**
   * Crée un nouvel enregistrement (alias français)
   */
  async creer(data) {
    return await this.create(data);
  }

  /**
   * Crée un nouvel enregistrement
   */
  async create(data) {
    try {
      // Validation et nettoyage des données
      let cleanData = this.fillableData(data);
      
      // Hook beforeCreate
      cleanData = await this.beforeCreate(cleanData);
      
      if (this.timestamps) {
        cleanData.date_creation = new Date().toISOString();
        cleanData.date_modification = new Date().toISOString();
      }

      // Validation métier
      await this.validate(cleanData, 'create');

      // Construction de la requête
      const fields = Object.keys(cleanData);
      const placeholders = fields.map(() => '?').join(', ');
      const values = Object.values(cleanData);

      const { sql, params } = this.convertPlaceholders(
        `INSERT INTO ${this.tableName} (${fields.join(', ')}) VALUES (${placeholders}) RETURNING ${this.primaryKey}`,
        values
      );

      const result = await db.get(sql, params);
      const insertedId = result[this.primaryKey];
      
      if (logManager.logDatabaseOperation) {
        logManager.logDatabaseOperation('create', this.tableName, insertedId, true);
      }
      
      // Retourne l'enregistrement créé
      const createdRecord = await this.findById(insertedId);
      
      // Hook afterCreate
      const finalRecord = await this.afterCreate(createdRecord);
      
      return finalRecord;
    } catch (error) {
      if (logManager.logDatabaseOperation) {
        logManager.logDatabaseOperation('create', this.tableName, null, false, error);
      }
      throw error;
    }
  }

  /**
   * Met à jour un enregistrement
   */
  async update(id, data) {
    try {
      let cleanData = this.fillableData(data);
      
      // Hook beforeUpdate
      cleanData = await this.beforeUpdate(cleanData);
      
      if (this.timestamps) {
        cleanData.date_modification = new Date().toISOString();
      }

      // Validation métier
      await this.validate(cleanData, 'update');

      const fields = Object.keys(cleanData);
      const setClause = fields.map(field => `${field} = ?`).join(', ');
      const values = [...Object.values(cleanData), id];

      const { sql, params } = this.convertPlaceholders(
        `UPDATE ${this.tableName} SET ${setClause} WHERE ${this.primaryKey} = ?`,
        values
      );

      const result = await db.run(sql, params);
      
      if (result.rowCount === 0) {
        throw new Error(`Aucun enregistrement trouvé avec l'ID ${id}`);
      }

      if (logManager.logDatabaseOperation) {
        logManager.logDatabaseOperation('update', this.tableName, id, true);
      }
      
      // Récupère l'enregistrement mis à jour
      const updatedRecord = await this.findById(id);
      
      // Hook afterUpdate
      const finalRecord = await this.afterUpdate(updatedRecord);
      
      return finalRecord;
    } catch (error) {
      if (logManager.logDatabaseOperation) {
        logManager.logDatabaseOperation('update', this.tableName, id, false, error);
      }
      throw error;
    }
  }

  /**
   * Supprime un enregistrement
   */
  async delete(id) {
    try {
      // Hook beforeDelete
      const canDelete = await this.beforeDelete(id);
      if (!canDelete) {
        throw new Error(`La suppression de l'enregistrement ${id} a été annulée par beforeDelete`);
      }
      
      const { sql, params } = this.convertPlaceholders(
        `DELETE FROM ${this.tableName} WHERE ${this.primaryKey} = ?`,
        [id]
      );
      const result = await db.run(sql, params);
      
      if (result.rowCount === 0) {
        throw new Error(`Aucun enregistrement trouvé avec l'ID ${id}`);
      }

      if (logManager.logDatabaseOperation) {
        logManager.logDatabaseOperation('delete', this.tableName, id, true);
      }
      
      // Hook afterDelete
      await this.afterDelete(id);
      
      return true;
    } catch (error) {
      if (logManager.logDatabaseOperation) {
        logManager.logDatabaseOperation('delete', this.tableName, id, false, error);
      }
      throw error;
    }
  }

  /**
   * Compte les enregistrements
   */
  async count(where = '', params = []) {
    try {
      const { sql, params: convertedParams } = this.convertPlaceholders(
        `SELECT COUNT(*) as count FROM ${this.tableName} ${where ? 'WHERE ' + where : ''}`,
        params
      );
      const result = await db.get(sql, convertedParams);
      return parseInt(result.count);
    } catch (error) {
      if (logManager.logDatabaseOperation) {
        logManager.logDatabaseOperation('read', this.tableName, null, false, error);
      }
      throw error;
    }
  }

  /**
   * Vérifie si un enregistrement existe
   */
  async exists(where, params = []) {
    const count = await this.count(where, params);
    return count > 0;
  }

  /**
   * Pagination
   */
  async paginate(page = 1, limit = 10, where = '', params = [], orderBy = 'id DESC') {
    try {
      const offset = (page - 1) * limit;
      
      // Compte total
      const total = await this.count(where, params);
      
      // Données paginées
      const { sql, params: convertedParams } = this.convertPlaceholders(
        `SELECT * FROM ${this.tableName} ${where ? 'WHERE ' + where : ''} ORDER BY ${orderBy} LIMIT ? OFFSET ?`,
        [...params, limit, offset]
      );
      const rows = await db.all(sql, convertedParams);

      return {
        data: rows.map(row => this.castAttributes(row)),
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit),
          hasNext: page &lt; Math.ceil(total / limit),
          hasPrev: page > 1
        }
      };
    } catch (error) {
      if (logManager.logDatabaseOperation) {
        logManager.logDatabaseOperation('read', this.tableName, null, false, error);
      }
      throw error;
    }
  }

  /**
   * Filtre les données selon les champs fillable/guarded
   */
  fillableData(data) {
    const result = {};
    
    Object.entries(data).forEach(([key, value]) => {
      // Si fillable est défini, seuls ces champs sont autorisés
      if (this.fillable.length > 0 &amp;&amp; !this.fillable.includes(key)) {
        return;
      }
      
      // Si le champ est dans guarded, on l'ignore
      if (this.guarded.includes(key)) {
        return;
      }
      
      result[key] = value;
    });
    
    return result;
  }

  /**
   * Applique les conversions de type automatiques
   */
  castAttributes(data) {
    if (!data) return data;
    
    const result = { ...data };
    
    Object.entries(this.casts).forEach(([field, type]) => {
      if (result[field] !== undefined &amp;&amp; result[field] !== null) {
        switch (type) {
          case 'json':
            try {
              result[field] = JSON.parse(result[field]);
            } catch (e) {
              logManager.warn(`Erreur parsing JSON pour ${field}`, { value: result[field] });
            }
            break;
          case 'boolean':
            result[field] = Boolean(result[field]);
            break;
          case 'integer':
            result[field] = parseInt(result[field]);
            break;
          case 'float':
            result[field] = parseFloat(result[field]);
            break;
          case 'date':
            result[field] = new Date(result[field]);
            break;
        }
      }
    });
    
    return result;
  }

  /**
   * Sérialise les données pour l'API (cache les champs hidden)
   */
  serialize(data) {
    if (!data) return data;
    
    const result = { ...data };
    
    this.hidden.forEach(field => {
      delete result[field];
    });
    
    return result;
  }

  /**
   * Schema Joi pour validation (à override dans les classes filles)
   */
  getValidationSchema(operation = 'create') {
    // Schema de base - à étendre dans les modèles spécifiques
    return Joi.object({});
  }

  /**
   * Validation métier avec Joi intégré
   */
  async validate(data, operation = 'create') {
    // Validation Joi si schema défini
    const schema = this.getValidationSchema(operation);
    if (schema &amp;&amp; Object.keys(schema.describe().keys || {}).length > 0) {
      // Ajouter les champs de timestamps automatiques au schema si nécessaire
      let schemaWithTimestamps = schema;
      if (this.timestamps &amp;&amp; (operation === 'create' || operation === 'update')) {
        schemaWithTimestamps = schema.keys({
          date_creation: Joi.string().optional(),
          date_modification: Joi.string().optional()
        });
      }
      
      const { error, value } = schemaWithTimestamps.validate(data, {
        abortEarly: false,
        allowUnknown: true, // Permet les champs supplémentaires pour la flexibilité
        stripUnknown: false
      });
      
      if (error) {
        const errorDetails = error.details.map(detail => ({
          field: detail.path.join('.'),
          message: detail.message,
          value: detail.context?.value
        }));
        
        const validationError = new Error(`Erreurs de validation: ${error.details.map(d => d.message).join(', ')}`);
        validationError.name = 'ValidationError';
        validationError.details = errorDetails;
        validationError.isJoi = true;
        throw validationError;
      }
      
      // Retourne les données nettoyées par Joi
      Object.assign(data, value);
    }
    
    // Validation métier spécifique (à étendre)
    return await this.businessValidation(data, operation);
  }

  /**
   * Validation métier spécifique (à override dans les classes filles)
   */
  async businessValidation(data, operation = 'create') {
    // Validation de base - à étendre dans les modèles spécifiques
    return true;
  }

  /**
   * Hooks appelés avant/après les opérations (à override)
   */
  async beforeCreate(data) { return data; }
  async afterCreate(record) { return record; }
  async beforeUpdate(data) { return data; }
  async afterUpdate(record) { return record; }
  async beforeDelete(id) { return true; }
  async afterDelete(id) { return true; }

  /**
   * Recherche textuelle simple
   */
  async search(query, fields = [], limit = 50) {
    if (!fields.length) {
      throw new Error('Champs de recherche requis');
    }
    
    const conditions = fields.map(field => `${field} LIKE ?`).join(' OR ');
    const params = fields.map(() => `%${query}%`);
    
    return await this.findAll(conditions, params, 'id DESC', limit);
  }

  /**
   * Batch operations
   */
  async bulkCreate(dataArray) {
    const results = [];
    
    for (const data of dataArray) {
      const record = await this.create(data);
      results.push(record);
    }
    
    return results;
  }

  /**
   * Upsert (update ou insert)
   */
  async upsert(data, uniqueField = 'id') {
    const existing = await this.findOne(`${uniqueField} = ?`, [data[uniqueField]]);
    
    if (existing) {
      return await this.update(existing[this.primaryKey], data);
    } else {
      return await this.create(data);
    }
  }

  /**
   * Soft delete (marque comme supprimé sans supprimer)
   */
  async softDelete(id) {
    return await this.update(id, { deleted_at: new Date().toISOString() });
  }

  /**
   * Restore un enregistrement soft deleted
   */
  async restore(id) {
    return await this.update(id, { deleted_at: null });
  }

  /**
   * Scope pour exclure les soft deleted
   */
  async findAllActive(where = '', params = [], orderBy = '') {
    const activeWhere = where ? `(${where}) AND deleted_at IS NULL` : 'deleted_at IS NULL';
    return await this.findAll(activeWhere, params, orderBy);
  }

  /**
   * Mise à jour partielle (patch)
   */
  async patch(id, data) {
    // Vérifie que l'enregistrement existe
    const existing = await this.findById(id);
    if (!existing) {
      throw new Error(`Aucun enregistrement trouvé avec l'ID ${id}`);
    }
    
    // Fusionne avec les données existantes
    const mergedData = { ...existing, ...data };
    return await this.update(id, mergedData);
  }

  /**
   * Transaction wrapper pour opérations complexes
   */
  async transaction(callback) {
    if (typeof callback !== 'function') {
      throw new Error('Le callback de transaction doit être une fonction');
    }
    
    try {
      await db.query('BEGIN');
      const result = await callback(this);
      await db.query('COMMIT');
      return result;
    } catch (error) {
      await db.query('ROLLBACK');
      throw error;
    }
  }

  /**
   * Génère un UUID v4 pour les clés primaires
   */
  generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r &amp; 0x3 | 0x8);
      return v.toString(16);
    });
  }

  /**
   * Validation des relations (clés étrangères)
   */
  async validateForeignKeys(data) {
    // À implémenter dans les modèles spécifiques si nécessaire
    return true;
  }

  /**
   * Log des changements pour audit trail
   */
  logChange(operation, id, oldData = null, newData = null) {
    if (logManager.logModelOperation) {
      logManager.logModelOperation(this.tableName, operation, id, {
        oldData,
        newData,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Méthode factory pour créer des instances avec données prédéfinies
   */
  static factory(overwrites = {}) {
    const instance = new this();
    return Object.assign(instance, overwrites);
  }

  /**
   * Trouve ou crée un enregistrement
   */
  async findOrCreate(findData, createData = {}) {
    const whereConditions = Object.keys(findData).map(key => `${key} = ?`).join(' AND ');
    const whereParams = Object.values(findData);
    
    const existing = await this.findOne(whereConditions, whereParams);
    
    if (existing) {
      return { record: existing, created: false };
    }
    
    const merged = { ...findData, ...createData };
    const created = await this.create(merged);
    return { record: created, created: true };
  }
}

module.exports = BaseModel;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Actualite.html">Actualite</a></li><li><a href="AdminController.html">AdminController</a></li><li><a href="AdminOracleService.html">AdminOracleService</a></li><li><a href="AnonymousTokenService.html">AnonymousTokenService</a></li><li><a href="AuthentificationController.html">AuthentificationController</a></li><li><a href="BaseController.html">BaseController</a></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="BasePdfKitService.html">BasePdfKitService</a></li><li><a href="BaseService.html">BaseService</a></li><li><a href="CacheService.html">CacheService</a></li><li><a href="CharacterSheetDocument.html">CharacterSheetDocument</a></li><li><a href="ClassPlanDocument.html">ClassPlanDocument</a></li><li><a href="DangerDocument.html">DangerDocument</a></li><li><a href="DemandeChangementEmail.html">DemandeChangementEmail</a></li><li><a href="Document.html">Document</a></li><li><a href="DocumentFactory.html">DocumentFactory</a></li><li><a href="DocumentModerationHistorique.html">DocumentModerationHistorique</a></li><li><a href="DocumentModerationService.html">DocumentModerationService</a></li><li><a href="DocumentSystemeJeu.html">DocumentSystemeJeu</a></li><li><a href="DocumentVote.html">DocumentVote</a></li><li><a href="DonationController.html">DonationController</a></li><li><a href="EmailService.html">EmailService</a></li><li><a href="EmailTemplate.html">EmailTemplate</a></li><li><a href="EngrenagesTheme.html">EngrenagesTheme</a></li><li><a href="GenericDocument.html">GenericDocument</a></li><li><a href="GroupDocument.html">GroupDocument</a></li><li><a href="HomeController.html">HomeController</a></li><li><a href="LoggingService.html">LoggingService</a></li><li><a href="MaintenanceWorker.html">MaintenanceWorker</a></li><li><a href="MarkdownService.html">MarkdownService</a></li><li><a href="Metro2033Theme.html">Metro2033Theme</a></li><li><a href="MistEngineTheme.html">MistEngineTheme</a></li><li><a href="ModerationController.html">ModerationController</a></li><li><a href="MonsterheartsTheme.html">MonsterheartsTheme</a></li><li><a href="Newsletter.html">Newsletter</a></li><li><a href="NewsletterService.html">NewsletterService</a></li><li><a href="Oracle.html">Oracle</a></li><li><a href="OracleController.html">OracleController</a></li><li><a href="OracleItem.html">OracleItem</a></li><li><a href="OracleService.html">OracleService</a></li><li><a href="OrganizationDocument.html">OrganizationDocument</a></li><li><a href="Pdf.html">Pdf</a></li><li><a href="PdfController.html">PdfController</a></li><li><a href="PdfKitService.html">PdfKitService</a></li><li><a href="PdfService.html">PdfService</a></li><li><a href="PerformanceMiddleware.html">PerformanceMiddleware</a></li><li><a href="PerformanceMonitoringService.html">PerformanceMonitoringService</a></li><li><a href="Personnage.html">Personnage</a></li><li><a href="PersonnageController.html">PersonnageController</a></li><li><a href="PersonnageService.html">PersonnageService</a></li><li><a href="ProductionApp.html">ProductionApp</a></li><li><a href="QueueService.html">QueueService</a></li><li><a href="QueueWorker.html">QueueWorker</a></li><li><a href="RgpdConsentement.html">RgpdConsentement</a></li><li><a href="RgpdService.html">RgpdService</a></li><li><a href="SecurityService.html">SecurityService</a></li><li><a href="ShareService.html">ShareService</a></li><li><a href="SystemCardViewModel.html">SystemCardViewModel</a></li><li><a href="SystemMaintenanceService.html">SystemMaintenanceService</a></li><li><a href="SystemRightsService.html">SystemRightsService</a></li><li><a href="SystemService.html">SystemService</a></li><li><a href="SystemTheme.html">SystemTheme</a></li><li><a href="SystemThemeService.html">SystemThemeService</a></li><li><a href="SystemeJeu.html">SystemeJeu</a></li><li><a href="Temoignage.html">Temoignage</a></li><li><a href="TemoignageService.html">TemoignageService</a></li><li><a href="TemplateService.html">TemplateService</a></li><li><a href="TownDocument.html">TownDocument</a></li><li><a href="Utilisateur.html">Utilisateur</a></li><li><a href="UtilisateurService.html">UtilisateurService</a></li><li><a href="VoteController.html">VoteController</a></li><li><a href="VoteService.html">VoteService</a></li><li><a href="ZombiologyTheme.html">ZombiologyTheme</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Joi">Joi</a></li><li><a href="global.html#asyncHandler">asyncHandler</a></li><li><a href="global.html#auth">auth</a></li><li><a href="global.html#compareVersions">compareVersions</a></li><li><a href="global.html#createError">createError</a></li><li><a href="global.html#createMigrationsTable">createMigrationsTable</a></li><li><a href="global.html#createTables">createTables</a></li><li><a href="global.html#database">database</a></li><li><a href="global.html#executeMigration">executeMigration</a></li><li><a href="global.html#getCurrentVersion">getCurrentVersion</a></li><li><a href="global.html#getErrorMessage">getErrorMessage</a></li><li><a href="global.html#getExecutedMigrations">getExecutedMigrations</a></li><li><a href="global.html#getMigrationStatus">getMigrationStatus</a></li><li><a href="global.html#getVersionsToMigrate">getVersionsToMigrate</a></li><li><a href="global.html#handleError">handleError</a></li><li><a href="global.html#handleNotFound">handleNotFound</a></li><li><a href="global.html#initializeDatabase">initializeDatabase</a></li><li><a href="global.html#isDatabaseInitialized">isDatabaseInitialized</a></li><li><a href="global.html#logger">logger</a></li><li><a href="global.html#markMigrationExecuted">markMigrationExecuted</a></li><li><a href="global.html#migrateDatabase">migrateDatabase</a></li><li><a href="global.html#migrateToLatest">migrateToLatest</a></li><li><a href="global.html#migrateToVersion">migrateToVersion</a></li><li><a href="global.html#migrations">migrations</a></li><li><a href="global.html#optionalAuth">optionalAuth</a></li><li><a href="global.html#path">path</a></li><li><a href="global.html#requireAdmin">requireAdmin</a></li><li><a href="global.html#requireAuth">requireAuth</a></li><li><a href="global.html#requirePremium">requirePremium</a></li><li><a href="global.html#resetDatabase">resetDatabase</a></li><li><a href="global.html#rollbackMigration">rollbackMigration</a></li><li><a href="global.html#schemas">schemas</a></li><li><a href="global.html#updateAppVersion">updateAppVersion</a></li><li><a href="global.html#validateFiles">validateFiles</a></li><li><a href="global.html#validateRequest">validateRequest</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Aug 08 2025 18:17:39 GMT+0200 (heure d’été d’Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
