<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/PersonnageService.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/PersonnageService.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const BaseService = require('./BaseService');
const Personnage = require('../models/Personnage');
const systemesJeu = require('../utils/systemesJeu');

/**
 * Service pour la gestion des personnages
 */
class PersonnageService extends BaseService {
    constructor() {
        super('PersonnageService');
        this.personnageModel = new Personnage();
    }

    /**
     * Liste les personnages d'un utilisateur avec filtres
     */
    async listerParUtilisateur(utilisateurId, filtres = {}, pagination = {}) {
        try {
            const conditions = ['utilisateur_id = ?'];
            const valeurs = [utilisateurId];
            
            // Filtres optionnels
            if (filtres.systeme_jeu) {
                conditions.push('systeme_jeu = ?');
                valeurs.push(filtres.systeme_jeu);
            }
            
            if (filtres.nom) {
                conditions.push('nom ILIKE ?');
                valeurs.push(`%${filtres.nom}%`);
            }
            
            const whereClause = conditions.join(' AND ');
            
            // Compter le total
            const total = await this.personnageModel.count(whereClause, valeurs);
            
            // Récupérer les personnages avec pagination
            const offset = pagination.offset || 0;
            const limite = pagination.limite || 20;
            
            const personnages = await this.personnageModel.findAll(
                whereClause + ` ORDER BY date_modification DESC LIMIT ${limite} OFFSET ${offset}`,
                valeurs
            );
            
            return { personnages, total };
            
        } catch (erreur) {
            this.logger.error('Erreur lors de la liste des personnages:', erreur);
            throw erreur;
        }
    }

    /**
     * Obtient un personnage par ID
     */
    async obtenirParId(id) {
        try {
            return await this.personnageModel.obtenirParId(id);
        } catch (erreur) {
            this.logger.error(`Erreur lors de la récupération du personnage ${id}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Crée un nouveau personnage
     */
    async creer(donnees) {
        try {
            // Valider le système de jeu
            if (!systemesJeu[donnees.systeme_jeu]) {
                throw new Error('Système de jeu invalide');
            }
            
            // Appliquer les valeurs par défaut du système
            const donneesCompletes = this.appliquerDefautsSysteme(donnees);
            
            // Valider les données
            this.validerDonnees(donneesCompletes);
            
            // Créer le personnage
            const personnage = await this.personnageModel.creer(donneesCompletes);
            
            this.logger.info('Personnage créé:', { 
                id: personnage.id, 
                nom: personnage.nom,
                systeme: personnage.systeme_jeu 
            });
            
            return personnage;
            
        } catch (erreur) {
            this.logger.error('Erreur lors de la création du personnage:', erreur);
            throw erreur;
        }
    }

    /**
     * Met à jour un personnage
     */
    async mettreAJour(id, donnees) {
        try {
            // Vérifier que le personnage existe
            const personnageExistant = await this.obtenirParId(id);
            if (!personnageExistant) {
                throw new Error('Personnage non trouvé');
            }
            
            // Fusionner avec les données existantes
            const donneesCompletes = { ...personnageExistant, ...donnees };
            
            // Valider les données
            this.validerDonnees(donneesCompletes);
            
            // Mettre à jour
            const personnageMisAJour = await this.personnageModel.mettreAJour(id, donnees);
            
            this.logger.info('Personnage mis à jour:', { 
                id: personnageMisAJour.id, 
                nom: personnageMisAJour.nom 
            });
            
            return personnageMisAJour;
            
        } catch (erreur) {
            this.logger.error(`Erreur lors de la mise à jour du personnage ${id}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Duplique un personnage
     */
    async dupliquer(idOriginal, nouveauNom, utilisateurId) {
        try {
            const personnageOriginal = await this.obtenirParId(idOriginal);
            if (!personnageOriginal) {
                throw new Error('Personnage original non trouvé');
            }
            
            // Préparer les données pour le nouveau personnage
            const nouvelleDonnees = {
                ...personnageOriginal,
                nom: nouveauNom,
                utilisateur_id: utilisateurId
            };
            
            // Supprimer les champs qui ne doivent pas être dupliqués
            delete nouvelleDonnees.id;
            delete nouvelleDonnees.date_creation;
            delete nouvelleDonnees.date_modification;
            
            // Créer le nouveau personnage
            const personnageDuplique = await this.creer(nouvelleDonnees);
            
            this.logger.info('Personnage dupliqué:', { 
                original: idOriginal, 
                nouveau: personnageDuplique.id 
            });
            
            return personnageDuplique;
            
        } catch (erreur) {
            this.logger.error(`Erreur lors de la duplication du personnage ${idOriginal}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Supprime un personnage
     */
    async supprimer(id) {
        try {
            // Vérifier que le personnage existe
            const personnage = await this.obtenirParId(id);
            if (!personnage) {
                throw new Error('Personnage non trouvé');
            }
            
            // Supprimer les PDFs associés (soft delete)
            await this.pdfService.supprimerParPersonnage(id);
            
            // Supprimer le personnage
            await this.personnageModel.supprimer(id);
            
            this.logger.info('Personnage supprimé:', { 
                id, 
                nom: personnage.nom 
            });
            
            return true;
            
        } catch (erreur) {
            this.logger.error(`Erreur lors de la suppression du personnage ${id}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Sauvegarde un brouillon
     */
    async sauvegarderBrouillon(donnees) {
        try {
            // Les brouillons ont une validation plus souple
            const donneesBrouillon = {
                ...donnees,
                est_brouillon: true
            };
            
            // Validation minimale pour les brouillons
            if (!donneesBrouillon.nom || !donneesBrouillon.systeme_jeu) {
                throw new Error('Nom et système requis même pour un brouillon');
            }
            
            if (donneesBrouillon.id) {
                return await this.mettreAJour(donneesBrouillon.id, donneesBrouillon);
            } else {
                return await this.creer(donneesBrouillon);
            }
            
        } catch (erreur) {
            this.logger.error('Erreur lors de la sauvegarde du brouillon:', erreur);
            throw erreur;
        }
    }

    /**
     * Recherche de personnages
     */
    async rechercher(utilisateurId, terme, options = {}) {
        try {
            const conditions = ['utilisateur_id = ?'];
            const valeurs = [utilisateurId];
            
            // Recherche dans le nom et la description
            conditions.push('(nom ILIKE ? OR description ILIKE ?)');
            valeurs.push(`%${terme}%`, `%${terme}%`);
            
            // Filtre par système si spécifié
            if (options.systeme) {
                conditions.push('systeme_jeu = ?');
                valeurs.push(options.systeme);
            }
            
            const limite = Math.min(options.limite || 10, 50);
            
            const personnages = await this.personnageModel.lister({
                where: conditions.join(' AND '),
                valeurs,
                order: 'nom ASC',
                limit: limite
            });
            
            return personnages;
            
        } catch (erreur) {
            this.logger.error('Erreur lors de la recherche:', erreur);
            throw erreur;
        }
    }

    /**
     * Obtient les statistiques des personnages d'un utilisateur
     */
    async obtenirStatistiques(utilisateurId) {
        try {
            const stats = await this.personnageModel.obtenirStatistiques(utilisateurId);
            
            return {
                total: stats.total || 0,
                par_systeme: stats.par_systeme || {},
                recents: stats.recents || [],
                brouillons: stats.brouillons || 0
            };
            
        } catch (erreur) {
            this.logger.error('Erreur lors du calcul des statistiques:', erreur);
            throw erreur;
        }
    }

    /**
     * Génère un PDF pour un personnage
     */
    async genererPdf(personnageId, typePdf = 'fiche_personnage', options = {}) {
        try {
            const personnage = await this.obtenirParId(personnageId);
            if (!personnage) {
                throw new Error('Personnage non trouvé');
            }
            
            // Déléguer à PdfService
            return await this.pdfService.demarrerGeneration(
                personnageId,
                personnage.utilisateur_id,
                {
                    type_pdf: typePdf,
                    options_generation: options,
                    format: options.format || 'A4',
                    orientation: options.orientation || 'portrait'
                }
            );
            
        } catch (erreur) {
            this.logger.error(`Erreur lors de la génération PDF pour ${personnageId}:`, erreur);
            throw erreur;
        }
    }

    /**
     * Crée un template de personnage pour un système
     */
    creerTemplate(systemeJeu) {
        const systeme = systemesJeu[systemeJeu];
        if (!systeme) {
            throw new Error('Système de jeu invalide');
        }
        
        const template = {
            nom: '',
            systeme_jeu: systemeJeu,
            attributs: {},
            competences: {},
            infos_base: {},
            inventaire: [],
            notes: '',
            est_brouillon: true
        };
        
        // Initialiser les attributs avec les valeurs par défaut
        if (systeme.attributs) {
            Object.entries(systeme.attributs).forEach(([nom, config]) => {
                template.attributs[nom] = config.defaut || config.min || 0;
            });
        }
        
        // Initialiser les compétences
        if (systeme.competences) {
            Object.keys(systeme.competences).forEach(competence => {
                template.competences[competence] = 0;
            });
        }
        
        // Initialiser les infos de base
        if (systeme.infos_base) {
            Object.keys(systeme.infos_base.champs || {}).forEach(champ => {
                template.infos_base[champ] = '';
            });
        }
        
        return template;
    }

    /**
     * Applique les valeurs par défaut d'un système
     */
    appliquerDefautsSysteme(donnees) {
        const systeme = systemesJeu[donnees.systeme_jeu];
        if (!systeme) return donnees;
        
        const donneesCompletes = { ...donnees };
        
        // Appliquer les défauts des attributs
        if (systeme.attributs &amp;&amp; !donneesCompletes.attributs) {
            donneesCompletes.attributs = {};
            Object.entries(systeme.attributs).forEach(([nom, config]) => {
                donneesCompletes.attributs[nom] = config.defaut || config.min || 0;
            });
        }
        
        // Initialiser les autres champs si manquants
        donneesCompletes.competences = donneesCompletes.competences || {};
        donneesCompletes.infos_base = donneesCompletes.infos_base || {};
        donneesCompletes.inventaire = donneesCompletes.inventaire || [];
        donneesCompletes.notes = donneesCompletes.notes || '';
        
        return donneesCompletes;
    }

    /**
     * Valide les données d'un personnage
     */
    validerDonnees(donnees) {
        const erreurs = [];
        
        // Validation de base
        if (!donnees.nom || donnees.nom.trim().length &lt; 2) {
            erreurs.push('Le nom doit contenir au moins 2 caractères');
        }
        
        if (!donnees.systeme_jeu || !systemesJeu[donnees.systeme_jeu]) {
            erreurs.push('Système de jeu invalide');
        }
        
        // Validation spécifique au système
        if (donnees.systeme_jeu &amp;&amp; systemesJeu[donnees.systeme_jeu]) {
            const systeme = systemesJeu[donnees.systeme_jeu];
            
            // Valider les attributs
            if (donnees.attributs &amp;&amp; systeme.attributs) {
                Object.entries(systeme.attributs).forEach(([nom, config]) => {
                    const valeur = donnees.attributs[nom];
                    if (valeur !== undefined &amp;&amp; valeur !== null) {
                        if (typeof valeur !== 'number' || valeur &lt; config.min || valeur > config.max) {
                            erreurs.push(`${nom} doit être un nombre entre ${config.min} et ${config.max}`);
                        }
                    }
                });
            }
            
            // Valider les champs requis (sauf pour les brouillons)
            if (!donnees.est_brouillon &amp;&amp; systeme.infos_base?.requis) {
                systeme.infos_base.requis.forEach(champ => {
                    const valeur = donnees.infos_base?.[champ] || donnees[champ];
                    if (!valeur || (typeof valeur === 'string' &amp;&amp; valeur.trim() === '')) {
                        erreurs.push(`${champ} est requis pour ${systeme.nom}`);
                    }
                });
            }
        }
        
        if (erreurs.length > 0) {
            const erreur = new Error(erreurs.join(', '));
            erreur.name = 'ValidationError';
            erreur.details = erreurs;
            throw erreur;
        }
    }

    /**
     * Nettoie les brouillons anciens
     */
    async nettoyerBrouillonsAnciens(joursAnciennete = 30) {
        try {
            const dateLimit = new Date();
            dateLimit.setDate(dateLimit.getDate() - joursAnciennete);
            
            const nbSupprimes = await this.personnageModel.supprimerBrouillonsAnciens(dateLimit);
            
            this.logger.info(`${nbSupprimes} brouillons anciens nettoyés`);
            return nbSupprimes;
            
        } catch (erreur) {
            this.logger.error('Erreur lors du nettoyage des brouillons:', erreur);
            throw erreur;
        }
    }
}

module.exports = PersonnageService;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Actualite.html">Actualite</a></li><li><a href="AdminController.html">AdminController</a></li><li><a href="AdminOracleService.html">AdminOracleService</a></li><li><a href="AnonymousTokenService.html">AnonymousTokenService</a></li><li><a href="AuthentificationController.html">AuthentificationController</a></li><li><a href="BaseController.html">BaseController</a></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="BasePdfKitService.html">BasePdfKitService</a></li><li><a href="BaseService.html">BaseService</a></li><li><a href="CharacterSheetDocument.html">CharacterSheetDocument</a></li><li><a href="ClassPlanDocument.html">ClassPlanDocument</a></li><li><a href="DocumentFactory.html">DocumentFactory</a></li><li><a href="DonationController.html">DonationController</a></li><li><a href="EmailService.html">EmailService</a></li><li><a href="EmailTemplate.html">EmailTemplate</a></li><li><a href="EngrenagesTheme.html">EngrenagesTheme</a></li><li><a href="GenericDocument.html">GenericDocument</a></li><li><a href="HomeController.html">HomeController</a></li><li><a href="MarkdownService.html">MarkdownService</a></li><li><a href="Metro2033Theme.html">Metro2033Theme</a></li><li><a href="MonsterheartsTheme.html">MonsterheartsTheme</a></li><li><a href="Newsletter.html">Newsletter</a></li><li><a href="NewsletterService.html">NewsletterService</a></li><li><a href="Oracle.html">Oracle</a></li><li><a href="OracleController.html">OracleController</a></li><li><a href="OracleItem.html">OracleItem</a></li><li><a href="OracleService.html">OracleService</a></li><li><a href="Pdf.html">Pdf</a></li><li><a href="PdfController.html">PdfController</a></li><li><a href="PdfKitService.html">PdfKitService</a></li><li><a href="PdfService.html">PdfService</a></li><li><a href="Personnage.html">Personnage</a></li><li><a href="PersonnageController.html">PersonnageController</a></li><li><a href="PersonnageService.html">PersonnageService</a></li><li><a href="ShareService.html">ShareService</a></li><li><a href="SystemRightsService.html">SystemRightsService</a></li><li><a href="SystemService.html">SystemService</a></li><li><a href="SystemTheme.html">SystemTheme</a></li><li><a href="Temoignage.html">Temoignage</a></li><li><a href="TemoignageService.html">TemoignageService</a></li><li><a href="TemplateService.html">TemplateService</a></li><li><a href="Utilisateur.html">Utilisateur</a></li><li><a href="UtilisateurService.html">UtilisateurService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#compareVersions">compareVersions</a></li><li><a href="global.html#createMigrationsTable">createMigrationsTable</a></li><li><a href="global.html#createTables">createTables</a></li><li><a href="global.html#executeMigration">executeMigration</a></li><li><a href="global.html#getCurrentVersion">getCurrentVersion</a></li><li><a href="global.html#getExecutedMigrations">getExecutedMigrations</a></li><li><a href="global.html#getMigrationStatus">getMigrationStatus</a></li><li><a href="global.html#getVersionsToMigrate">getVersionsToMigrate</a></li><li><a href="global.html#initializeDatabase">initializeDatabase</a></li><li><a href="global.html#isDatabaseInitialized">isDatabaseInitialized</a></li><li><a href="global.html#markMigrationExecuted">markMigrationExecuted</a></li><li><a href="global.html#migrateDatabase">migrateDatabase</a></li><li><a href="global.html#migrateToLatest">migrateToLatest</a></li><li><a href="global.html#migrateToVersion">migrateToVersion</a></li><li><a href="global.html#migrations">migrations</a></li><li><a href="global.html#resetDatabase">resetDatabase</a></li><li><a href="global.html#rollbackMigration">rollbackMigration</a></li><li><a href="global.html#updateAppVersion">updateAppVersion</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Jul 23 2025 17:42:32 GMT+0200 (heure d’été d’Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
