<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/SystemRightsService.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/SystemRightsService.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Service pour la gestion des droits système
 * Respecte le principe de responsabilité unique (SOLID)
 */
class SystemRightsService {
    constructor() {
        this.validRights = ['public', 'private', 'common'];
    }

    /**
     * Valide si un droit système est valide
     * @param {string} systemRights - Le droit à valider
     * @returns {boolean}
     */
    isValidSystemRights(systemRights) {
        return this.validRights.includes(systemRights);
    }

    /**
     * Détermine les droits système pour un utilisateur et un document
     * @param {number|null} userId - ID utilisateur (0 pour anonyme, null pour non défini)
     * @param {Object} documentData - Données du document
     * @returns {string} - 'public', 'private', ou 'common'
     */
    determineSystemRights(userId, documentData = {}) {
        // Si explicitement défini et valide
        if (documentData.system_rights &amp;&amp; this.isValidSystemRights(documentData.system_rights)) {
            return documentData.system_rights;
        }

        // Si utilisateur anonyme (userId = 0 ou null)
        if (!userId || userId === 0) {
            // Documents anonymes sont privés par défaut, sauf si partagés
            if (this.hasActiveSharing(documentData)) {
                return 'public';
            }
            return 'private';
        }

        // Pour utilisateurs connectés
        if (this.hasActiveSharing(documentData)) {
            return 'public';
        }

        // Par défaut privé pour utilisateurs connectés
        return 'private';
    }

    /**
     * Vérifie si le document a un partage actif
     * @param {Object} documentData - Données du document
     * @returns {boolean}
     */
    hasActiveSharing(documentData) {
        if (!documentData.url_partage) {
            return false;
        }

        try {
            const shareData = typeof documentData.url_partage === 'string' 
                ? JSON.parse(documentData.url_partage) 
                : documentData.url_partage;

            return shareData.active &amp;&amp; new Date(shareData.expiration) > new Date();
        } catch (error) {
            return false;
        }
    }

    /**
     * Génère un chemin PDF complet avec nom de fichier horodaté
     * Format: {userId}_{systemRights}_{template}_{YYYYMMDD-HHMMSS}.pdf
     * @param {string} titre - Titre du document
     * @param {string|null} systeme - Système de jeu (null pour générique)
     * @param {number|null} userId - ID utilisateur (0 pour anonyme)
     * @param {string} template - Template utilisé
     * @param {string} systemRights - Droits système
     * @returns {Object} - {fileName, fullPath}
     */
    generatePdfPath(titre, systeme, userId = null, template = 'default', systemRights = 'private') {
        const path = require('path');
        
        // Générer un timestamp lisible : YYYYMMDD-HHMMSS
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hour = String(now.getHours()).padStart(2, '0');
        const minute = String(now.getMinutes()).padStart(2, '0');
        const second = String(now.getSeconds()).padStart(2, '0');
        
        const timestamp = `${year}${month}${day}-${hour}${minute}${second}`;
        
        // Formater les composants
        const userPart = userId &amp;&amp; userId > 0 ? userId : 0;
        const rightsPart = this.isValidSystemRights(systemRights) ? systemRights : 'private';
        const templatePart = template;
        
        // Construire le nom de fichier avec timestamp
        const fileName = `${userPart}_${rightsPart}_${templatePart}_${timestamp}.pdf`;
        
        // Gérer le système null (générique)
        const systemFolder = systeme || 'generique';
        
        // Construire le chemin complet
        const fullPath = path.join('output', 'pdfs', systemFolder, fileName);
        
        return {
            fileName,
            fullPath
        };
    }

    /**
     * Parse un nom de fichier pour extraire les composants
     * Supporte les formats: ancien (user-X_rights-Y), avec uniqueId (X_Y_Z_ID) et avec timestamp (X_Y_Z_YYYYMMDD-HHMMSS)
     * @param {string} filename - Nom de fichier
     * @returns {Object|null} - {userId, systemRights, template, uniqueId, timestamp} ou null
     */
    parseFilename(filename) {
        // Format avec timestamp: userId_systemRights_template_YYYYMMDD-HHMMSS.pdf
        const timestampFormatRegex = /^([^_]+)_([^_]+)_([^_]+)_(\d{8}-\d{6})\.pdf$/;
        const timestampMatch = filename.match(timestampFormatRegex);
        
        if (timestampMatch) {
            const userId = timestampMatch[1] === '0' ? 0 : parseInt(timestampMatch[1], 10);
            const systemRights = timestampMatch[2];
            
            return {
                userId: isNaN(userId) ? 0 : userId,
                systemRights: this.isValidSystemRights(systemRights) ? systemRights : 'private',
                template: timestampMatch[3],
                timestamp: timestampMatch[4],
                format: 'timestamp'
            };
        }
        
        // Format avec uniqueId: userId_systemRights_template_uniqueId.pdf (rétrocompatibilité)
        const uniqueIdFormatRegex = /^([^_]+)_([^_]+)_([^_]+)_([^.]+)\.pdf$/;
        const uniqueIdMatch = filename.match(uniqueIdFormatRegex);
        
        if (uniqueIdMatch) {
            const userId = uniqueIdMatch[1] === '0' ? 0 : parseInt(uniqueIdMatch[1], 10);
            const systemRights = uniqueIdMatch[2];
            
            return {
                userId: isNaN(userId) ? 0 : userId,
                systemRights: this.isValidSystemRights(systemRights) ? systemRights : 'private',
                template: uniqueIdMatch[3],
                uniqueId: uniqueIdMatch[4],
                format: 'uniqueId'
            };
        }
        
        // Ancien format: user-X_rights-Y_template-Z_id-ID.pdf (rétrocompatibilité)
        const oldFormatRegex = /user-([^_]+)_rights-([^_]+)_template-([^_]+)_id-([^.]+)\.pdf$/;
        const oldMatch = filename.match(oldFormatRegex);
        
        if (oldMatch) {
            const userId = oldMatch[1] === '0' ? 0 : parseInt(oldMatch[1], 10);
            const systemRights = oldMatch[2];
            
            return {
                userId: isNaN(userId) ? 0 : userId,
                systemRights: this.isValidSystemRights(systemRights) ? systemRights : 'private',
                template: oldMatch[3],
                uniqueId: oldMatch[4],
                format: 'legacy'
            };
        }
        
        return null;
    }

    /**
     * Vérifie si un utilisateur peut accéder à un document
     * @param {number|null} userId - ID de l'utilisateur demandeur
     * @param {Object} documentData - Données du document
     * @returns {boolean}
     */
    canUserAccessDocument(userId, documentData) {
        const systemRights = documentData.system_rights || 'private';

        switch (systemRights) {
            case 'public':
                return true; // Tout le monde peut accéder

            case 'common':
                return userId &amp;&amp; userId > 0; // Seuls les utilisateurs connectés

            case 'private':
            default:
                // Seul le propriétaire ou partage actif
                return (
                    (userId &amp;&amp; documentData.utilisateur_id === userId) ||
                    this.hasActiveSharing(documentData)
                );
        }
    }

    /**
     * Vérifie si un utilisateur peut modifier un document
     * @param {number|null} userId - ID de l'utilisateur demandeur
     * @param {Object} documentData - Données du document
     * @returns {boolean}
     */
    canUserModifyDocument(userId, documentData) {
        // Seul le propriétaire peut modifier
        return userId &amp;&amp; documentData.utilisateur_id === userId;
    }

    /**
     * Obtient la liste des droits système disponibles pour un utilisateur
     * @param {number|null} userId - ID utilisateur
     * @param {string} userType - Type d'utilisateur ('ADMIN', 'PREMIUM', 'STANDARD')
     * @returns {Array&lt;string>}
     */
    getAvailableRightsForUser(userId, userType = 'STANDARD') {
        if (!userId || userId === 0) {
            // Utilisateurs anonymes ne peuvent créer que des documents privés
            return ['private'];
        }

        switch (userType) {
            case 'ADMIN':
                return ['public', 'private', 'common']; // Admins ont tous les droits

            case 'PREMIUM':
                return ['public', 'private', 'common']; // Premium ont tous les droits

            case 'STANDARD':
            default:
                return ['private', 'common']; // Standard peuvent faire privé et commun
        }
    }

    /**
     * Migre les anciens formats vers le nouveau système
     * @param {Object} oldData - Anciennes données
     * @returns {Object} - Nouvelles données
     */
    migrateFromLegacyFormat(oldData) {
        const newData = { ...oldData };

        // Migration statut_visibilite -> system_rights
        if (oldData.statut_visibilite &amp;&amp; !oldData.system_rights) {
            switch (oldData.statut_visibilite) {
                case 'PUBLIC':
                    newData.system_rights = 'public';
                    break;
                case 'COMMUNAUTAIRE':
                    newData.system_rights = 'common';
                    break;
                case 'PRIVATE':
                default:
                    newData.system_rights = 'private';
                    break;
            }
        }

        // Assurer que system_rights est défini
        if (!newData.system_rights) {
            newData.system_rights = 'private';
        }

        return newData;
    }
}

module.exports = SystemRightsService;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Actualite.html">Actualite</a></li><li><a href="AnonymousTokenService.html">AnonymousTokenService</a></li><li><a href="AuthentificationController.html">AuthentificationController</a></li><li><a href="BaseController.html">BaseController</a></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="BasePdfKitService.html">BasePdfKitService</a></li><li><a href="BaseService.html">BaseService</a></li><li><a href="CharacterSheetDocument.html">CharacterSheetDocument</a></li><li><a href="ClassPlanDocument.html">ClassPlanDocument</a></li><li><a href="DocumentFactory.html">DocumentFactory</a></li><li><a href="DonationController.html">DonationController</a></li><li><a href="GenericDocument.html">GenericDocument</a></li><li><a href="HomeController.html">HomeController</a></li><li><a href="MarkdownService.html">MarkdownService</a></li><li><a href="MonsterheartsTheme.html">MonsterheartsTheme</a></li><li><a href="Newsletter.html">Newsletter</a></li><li><a href="NewsletterService.html">NewsletterService</a></li><li><a href="Pdf.html">Pdf</a></li><li><a href="PdfController.html">PdfController</a></li><li><a href="PdfKitService.html">PdfKitService</a></li><li><a href="PdfService.html">PdfService</a></li><li><a href="Personnage.html">Personnage</a></li><li><a href="PersonnageController.html">PersonnageController</a></li><li><a href="PersonnageService.html">PersonnageService</a></li><li><a href="SystemRightsService.html">SystemRightsService</a></li><li><a href="SystemTheme.html">SystemTheme</a></li><li><a href="Temoignage.html">Temoignage</a></li><li><a href="TemoignageService.html">TemoignageService</a></li><li><a href="TemplateService.html">TemplateService</a></li><li><a href="Utilisateur.html">Utilisateur</a></li><li><a href="UtilisateurService.html">UtilisateurService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#compareVersions">compareVersions</a></li><li><a href="global.html#createMigrationsTable">createMigrationsTable</a></li><li><a href="global.html#createTables">createTables</a></li><li><a href="global.html#executeMigration">executeMigration</a></li><li><a href="global.html#getCurrentVersion">getCurrentVersion</a></li><li><a href="global.html#getExecutedMigrations">getExecutedMigrations</a></li><li><a href="global.html#getMigrationStatus">getMigrationStatus</a></li><li><a href="global.html#getVersionsToMigrate">getVersionsToMigrate</a></li><li><a href="global.html#initializeDatabase">initializeDatabase</a></li><li><a href="global.html#isDatabaseInitialized">isDatabaseInitialized</a></li><li><a href="global.html#markMigrationExecuted">markMigrationExecuted</a></li><li><a href="global.html#migrateDatabase">migrateDatabase</a></li><li><a href="global.html#migrateToLatest">migrateToLatest</a></li><li><a href="global.html#migrateToVersion">migrateToVersion</a></li><li><a href="global.html#migrations">migrations</a></li><li><a href="global.html#resetDatabase">resetDatabase</a></li><li><a href="global.html#rollbackMigration">rollbackMigration</a></li><li><a href="global.html#updateAppVersion">updateAppVersion</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Mon Jul 21 2025 16:01:04 GMT+0200 (heure d’été d’Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
